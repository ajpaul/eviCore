{"version":3,"sources":["webpack:///module-places/webpack/universalModuleDefinition","webpack:///module-places/scripts/main.js","webpack:///module-places/webpack/bootstrap d29fef576d576c86812f","webpack:///module-places/./scripts/main.js","webpack:///module-places/(webpack)/buildin/module.js","webpack:///module-places/external \"core\"","webpack:///module-places/external \"base\"","webpack:///module-places/external \"ui\"","webpack:///module-places/./scripts/libs/angular-gm.js","webpack:///module-places//maps.google.com/maps/api/js","webpack:///module-places/./scripts/utils.js","webpack:///module-places/./scripts/services.js","webpack:///module-places/./scripts/places-autocomplete.js","webpack:///module-places/external \"jquery\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_4__","__WEBPACK_EXTERNAL_MODULE_5__","__WEBPACK_EXTERNAL_MODULE_7__","__WEBPACK_EXTERNAL_MODULE_11__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","name","core","base","ui","deps","createModule","constant","service","directive","undefined","webpackPolyfill","deprecate","paths","children","angular","precision","markerConstructor","google","maps","Marker","polylineConstructor","Polyline","circleConstructor","Circle","mapOptions","zoom","center","LatLng","mapTypeId","MapTypeId","ROADMAP","$parse","$compile","$timeout","$log","angulargmUtils","angulargmShape","link","scope","element","attrs","controller","circleOptions","object","latLngObj","gmCircleCenter","objToLatLng","gmCircleOptions","options","extend","createShapeDirective","restrict","priority","gmObjects","gmId","opts","$eval","gmInfoWindowOptions","content","model","gmInfoWindow","infoWindow","InfoWindow","assign","handlers","getEventHandlers","forEach","handler","event","addListener","debounce","isDefined","gmCenter","gmBounds","bounds","gmMapId","hasCenter","hasZoom","hasBounds","hasMapTypeId","hasOwnProperty","_updateScope","$apply","s","gmZoom","b","gmMapTypeId","updateScope","addMapListener","map","getMap","ev","locals","$parent","$watchCollection","newValue","oldValue","changed","dragging","latLng","$watch","ok","isNaN","$on","mapTrigger","addMapListenerOnce","$emit","template","transclude","replace","gmMapOptions","markerOptions","gmPosition","position","gmMarkerOptions","gmEvents","polylineOptions","lineLatLngs","gmPath","path","latlng","warn","push","gmPolylineOptions","$q","addMap","mapId","Map","defers","resolve","getMapPromise","defer","promise","removeMap","clear","checkRequiredAttributes","_generateObjectCache","objects","objectCache","_addNewElements","type","optionsFn","getElement","$id","updateElement","addElement","context","version","major","minor","_removeOrphanedElements","orphaned","forEachElementInScope","removeElement","_formatEventName","uppercasePluralType","charAt","toUpperCase","slice","_attachEventListeners","updateElements","eventObj","ids","bind","trigger","objectsName","elementOptions","floatEqual","f1","f2","Math","abs","latLngEqual","l1","l2","lat","lng","boundsEqual","b1","b2","LatLngBounds","sw1","getSouthWest","sw2","ne1","getNorthEast","ne2","latLngToObj","obj","hasNaN","isNull","isNotaN","value","key","lastIndexOf","lowercase","substring","fn","assertDefined","func","wait","immediate","args","arguments","later","timeout","result","apply","callNow","cancel","$scope","$element","angulargmDefaults","angulargmContainer","constructor","mapDiv","firstChild","attr","config","_getConfig","_map","_createMap","_elements","_listeners","Object","defineProperties","writeable","configurable","get","getCenter","set","panTo","getZoom","setZoom","getBounds","numbers","fitBounds","getMapTypeId","setMapTypeId","_initDragListeners","_destroy","defaults","div","getDiv","replaceWith","setOptions","self","listener","l","removeListener","types","keys","scopeIds","_getElements","scopeId","streetView","getStreetView","getVisible","setVisible","addListenerOnce","_newElement","Array","hasElement","elements","setMap","removed","forEachElement","allElements","reduce","accumulator","lpPlacesUtils","maxLengthLabel","markerColorPool","markerWidth","markerHeight","markerFontFamily","titleField","alertTimeout","isCanvasSupported","document","createElement","getContext","window","lpPlaces","drawPin","width","height","radius","beginPath","moveTo","arc","PI","closePath","fill","stroke","getFilterOptions","data","services","concat","googleIcon","label","color","canvasIcon","canvas","clearRect","fillStyle","strokeStyle","fontSize","length","font","textBaseline","textWidth","measureText","fillText","floor","toDataURL","$inject","$","placesAutocomplete","lpCoreUtils","linkFn","ngModelCtrl","autocomplete","places","Autocomplete","place","getPlace","isValid","geometry","location","$setValidity","$setViewValue","val","onPlaceChange","e","keyCode","preventDefault","compile","on","DOMNodeInserted","addClass"],"mappings":"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","file":"scripts/main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"core\"), require(\"base\"), require(\"ui\"), require(\"async!//maps.google.com/maps/api/js?libraries=places\"), require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"core\", \"base\", \"ui\", \"async!//maps.google.com/maps/api/js?libraries=places\", \"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"module-places\"] = factory(require(\"core\"), require(\"base\"), require(\"ui\"), require(\"async!//maps.google.com/maps/api/js?libraries=places\"), require(\"jquery\"));\n\telse\n\t\troot[\"module-places\"] = factory(root[\"core\"], root[\"base\"], root[\"ui\"], root[\"async!//maps.google.com/maps/api/js?libraries=places\"], root[\"jquery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_11__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"core\"), require(\"base\"), require(\"ui\"), require(\"async!//maps.google.com/maps/api/js?libraries=places\"), require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"core\", \"base\", \"ui\", \"async!//maps.google.com/maps/api/js?libraries=places\", \"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"module-places\"] = factory(require(\"core\"), require(\"base\"), require(\"ui\"), require(\"async!//maps.google.com/maps/api/js?libraries=places\"), require(\"jquery\"));\n\telse\n\t\troot[\"module-places\"] = factory(root[\"core\"], root[\"base\"], root[\"ui\"], root[\"async!//maps.google.com/maps/api/js?libraries=places\"], root[\"jquery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_11__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';\n\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\t    'use strict';\n\n\t    module.name = 'module-places';\n\n\t    var core = __webpack_require__(3);\n\t    var base = __webpack_require__(4);\n\t    var ui = __webpack_require__(5);\n\t    __webpack_require__(6);\n\n\t    // requirejs async plugin\n\t    // Is ignored by webpack\n\t    __webpack_require__(7);\n\n\t    var deps = [core.name, ui.name, 'AngularGM'];\n\n\t    module.exports = base.createModule(module.name, deps).constant(__webpack_require__(8)).service(__webpack_require__(9)).directive(__webpack_require__(10));\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\t/*eslint-disable */\n\t/**\n\t * AngularGM - Google Maps Directives for AngularJS\n\t * @version v1.0.2 - 2015-06-17\n\t * @link http://dylanfprice.github.com/angular-gm\n\t * @author Dylan Price <the.dylan.price@gmail.com>\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t/**\n\t * @doc module\n\t * @name angulargm\n\t *\n\t * @description\n\t * Module for embedding Google Maps into AngularJS applications.\n\t *\n\t * # Example Plunkers ([fullscreen](http://embed.plnkr.co/PYDYjVuRHaJpdntoJtqL))\n\t *\n\t * <iframe style=\"width: 100%; height: 400px\" src=\"http://embed.plnkr.co/PYDYjVuRHaJpdntoJtqL\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\">\n\t * </iframe>\n\t *\n\t * Author: Dylan Price <the.dylan.price@gmail.com>\n\t */\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM', []).\n\n\t  /**\n\t   * @ngdoc service\n\t   * @name angulargm.service:angulargmDefaults\n\t   *\n\t   * @description\n\t   * Default configuration.\n\t   *\n\t   * To provide your own default config, use the following\n\t   * ```js\n\t   * angular.module('myModule').config(function($provide) {\n\t   *   $provide.decorator('angulargmDefaults', function($delegate) {\n\t   *     return angular.extend($delegate, {\n\t   *       'precision': 3,\n\t   *       'markerConstructor': myCustomMarkerConstructor,\n\t   *       'polylineConstructor': myCustomPolylineConstructor,\n\t   *       'mapOptions': {\n\t   *         center: new google.maps.LatLng(55, 111),\n\t   *         mapTypeId: google.maps.MapTypeId.SATELLITE,\n\t   *         ...\n\t   *       }\n\t   *     });\n\t   *   });\n\t   * });\n\t   * ```\n\t   */\n\t  factory('angulargmDefaults', function () {\n\t    return {\n\t      'precision': 3,\n\t      'markerConstructor': google.maps.Marker,\n\t      'polylineConstructor': google.maps.Polyline,\n\t      'circleConstructor': google.maps.Circle,\n\t      'mapOptions': {\n\t        zoom: 8,\n\t        center: new google.maps.LatLng(46, -120),\n\t        mapTypeId: google.maps.MapTypeId.ROADMAP\n\t      }\n\t    };\n\t  });\n\t})();\n\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').directive('gmCircles', ['$parse', '$compile', '$timeout', '$log', 'angulargmUtils', 'angulargmShape', function ($parse, $compile, $timeout, $log, angulargmUtils, angulargmShape) {\n\n\t    var objToLatLng = angulargmUtils.objToLatLng;\n\n\t    function link(scope, element, attrs, controller) {\n\t      if (!('gmCircleCenter' in attrs)) {\n\t        throw 'gmCircleCenter attribute required';\n\t      }\n\n\t      var circleOptions = function circleOptions(object) {\n\t        var latLngObj = scope.gmCircleCenter({ object: object });\n\t        var center = objToLatLng(latLngObj);\n\t        if (center == null) {\n\t          return null;\n\t        }\n\t        var circleOptions = scope.gmCircleOptions({ object: object });\n\t        var options = {};\n\t        angular.extend(options, circleOptions, { center: center });\n\t        return options;\n\t      };\n\n\t      angulargmShape.createShapeDirective('circle', scope, attrs, controller, circleOptions);\n\t    }\n\n\t    return {\n\t      restrict: 'AE',\n\t      priority: 100,\n\t      scope: {\n\t        gmObjects: '&',\n\t        gmId: '&',\n\t        gmCircleCenter: '&',\n\t        gmCircleOptions: '&'\n\t      },\n\t      require: '^gmMap',\n\t      link: link\n\t    };\n\t  }]);\n\t})();\n\t/**\n\t * @ngdoc directive\n\t * @name angulargm.directive:gmInfoWindow\n\t * @element ANY\n\t *\n\t * @description\n\t * A directive for creating a google.maps.InfoWindow.\n\t *\n\t * @param {expression} gm-info-window scope variable to store the\n\t * [google.maps.InfoWindow](https://developers.google.com/maps/documentation/javascript/reference#InfoWindow)\n\t * in. Does not have to already exist.\n\t *\n\t * @param {expression} gm-info-window-options object in the current scope\n\t * that is a\n\t * [google.maps.InfoWindowOptions](https://developers.google.com/maps/documentation/javascript/reference#InfoWindowOptions)\n\t * object. If unspecified, google maps api defaults will be used.\n\t *\n\t * @param {expression} gm-on-*event* an angular expression which evaluates to an\n\t * event handler. This handler will be attached to the InfoWindow's \\*event\\*\n\t * event.  The variable `infoWindow` evaluates to the InfoWindow.  For example:\n\t * ```html\n\t * gm-on-closeclick=\"myCloseclickFn(infoWindow)\"\n\t * ```\n\t * will call your myCloseclickFn whenever the InfoWindow is clicked closed. You\n\t * may have multiple `gm-on-*event*` handlers, but only one for each type of\n\t * event.\n\t */\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').\n\n\t  /*\n\t   * Much of this code is taken from the Angular UI team, see:\n\t   * https://github.com/angular-ui/ui-map/blob/master/ui-map.js\n\t   */\n\t  directive('gmInfoWindow', ['$parse', '$compile', '$timeout', 'angulargmUtils', function ($parse, $compile, $timeout, angulargmUtils) {\n\n\t    /** aliases */\n\t    var getEventHandlers = angulargmUtils.getEventHandlers;\n\n\t    function link(scope, element, attrs, controller) {\n\t      var opts = angular.extend({}, scope.$eval(attrs.gmInfoWindowOptions));\n\t      opts.content = element[0];\n\t      var model = $parse(attrs.gmInfoWindow);\n\t      var infoWindow = model(scope);\n\n\t      if (!infoWindow) {\n\t        infoWindow = new google.maps.InfoWindow(opts);\n\t        model.assign(scope, infoWindow);\n\t      }\n\n\t      var handlers = getEventHandlers(attrs);\n\n\t      // set up info window event handlers\n\t      angular.forEach(handlers, function (handler, event) {\n\t        google.maps.event.addListener(infoWindow, event, function () {\n\t          $timeout(function () {\n\t            handler(scope, {\n\t              infoWindow: infoWindow\n\t            });\n\t          });\n\t        });\n\t      });\n\t    }\n\n\t    return {\n\t      restrict: 'A',\n\t      priority: 100,\n\t      scope: false,\n\t      link: link\n\t    };\n\t  }]);\n\t})();\n\n\t/**\n\t * @ngdoc directive\n\t * @name angulargm.directive:gmMap\n\t * @element ANY\n\t *\n\t * @description\n\t * A directive for embedding google maps into your app.\n\t *\n\t * `gm-map-id` is required. The `gm-center`, `gm-zoom`, `gm-bounds`, and\n\t * `gm-map-type-id` variables do not have to exist in the current scope--they\n\t * will be created if necessary. All three have bi-directional association,\n\t * i.e.  drag or zoom the map and they will update, update them and the map\n\t * will change.  However, any initial state of these three variables will be\n\t * ignored.\n\t *\n\t * If you need to get a handle on the google.maps.Map object, see\n\t * {@link angulargm.service:angulargmContainer angulargmContainer}\n\t *\n\t * @param {expression} gm-map-id angular expression that evaluates to a unique\n\t * string id for the map, e.g. `'map_canvas'` or `myMapId` where myMapId is a\n\t * variable in the current scope. This allows you to have multiple\n\t * maps/instances of the directive.\n\t *\n\t *\n\t * @param {expression} gm-center center variable in the current scope.  The\n\t * value will be a google.maps.LatLng object.\n\t *\n\t *\n\t * @param {expression} gm-zoom zoom variable in the current scope.  Value will\n\t * be an integer.\n\t *\n\t *\n\t * @param {expression} gm-bounds bounds variable in the current scope.  Value\n\t * will be a google.maps.LatLngBounds object.\n\t *\n\t *\n\t * @param {expression} gm-map-type-id mapTypeId variable in the current scope.\n\t * Value will be a string.\n\t *\n\t *\n\t * @param {expression} gm-map-options object in the current scope that is a\n\t * google.maps.MapOptions object. If unspecified, will use the values in\n\t * angulargmDefaults.mapOptions. {@link angulargm.service:angulargmDefaults angulargmDefaults} is a service, so it is\n\t * both injectable and overrideable (using $provide.decorator).\n\t *\n\t * @param {expression} gm-on-*event* an angular expression which evaluates to\n\t * an event handler. This handler will be attached to each marker's \\*event\\*\n\t * event.  The variables 'map' and 'event' evaluate to the map and the\n\t * [google.maps.MouseEvent](https://developers.google.com/maps/documentation/javascript/reference#MouseEvent),\n\t * respectively. The map is always passed in, but the MouseEvent is only passed in if the event emits it.  For example:\n\t * ```html\n\t * gm-on-click=\"myClickFn(map, event)\"\n\t * ```\n\t * will call your `myClickFn` whenever the map is clicked.  You may have\n\t * multiple `gm-on-*event*` handlers, but only one for each type of event.  For events that have an underscore in their\n\t * name, such as 'center_changed', write it as 'gm-on-center-changed'.\n\t *\n\t *\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @name angulargm.directive:gmMap#gmMapResize\n\t * @eventOf angulargm.directive:gmMap\n\t * @eventType listen on current gmMap scope\n\t *\n\t * @description Alias for google.maps.event.trigger(map, 'resize')\n\t *\n\t * @param {string} mapId Required. The id of your map.\n\t * @example\n\t * ```js\n\t * $scope.$broadcast('gmMapResize', 'myMapId')\n\t * ```\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @name angulargm.directive:gmMap#gmMapIdle\n\t * @eventOf angulargm.directive:gmMap\n\t * @eventType emit on current gmMap scope\n\t *\n\t * @description Emitted when the map is finished loading (when the map fires\n\t * the 'idle' event).\n\t *\n\t * @param {string} mapId the id of the map which finished loading.\n\t *\n\t * @example\n\t * ```js\n\t * $scope.$on('gmMapIdle', function(event, mapId) {\n\t *     if (mapId === 'myMapId') {\n\t *       ...\n\t *     }\n\t * });\n\t * ```\n\t */\n\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').directive('gmMap', ['$timeout', 'angulargmUtils', 'debounce', function ($timeout, angulargmUtils, debounce) {\n\n\t    /** aliases **/\n\t    var getEventHandlers = angulargmUtils.getEventHandlers;\n\n\t    /** link function **/\n\t    function link(scope, element, attrs, controller) {\n\t      // initialize scope\n\t      if (!angular.isDefined(scope.gmCenter)) {\n\t        scope.center = {};\n\t      }\n\t      if (!angular.isDefined(scope.gmBounds)) {\n\t        scope.bounds = {};\n\t      }\n\n\t      // Make sure gmMapId is defined\n\t      // Note: redundant check in MapController. Can't hurt.\n\t      if (!angular.isDefined(scope.gmMapId)) {\n\t        throw 'angulargm must have non-empty gmMapId attribute';\n\t      }\n\n\t      // Check what's defined in attrs\n\t      // Note: this is also redundant since angular will throw an exception if\n\t      // these attributes are not set. I may make these optional in the future\n\t      // (pending angular support).\n\t      var hasCenter = false;\n\t      var hasZoom = false;\n\t      var hasBounds = false;\n\t      var hasMapTypeId = false;\n\n\t      if (attrs.hasOwnProperty('gmCenter')) {\n\t        hasCenter = true;\n\t      }\n\t      if (attrs.hasOwnProperty('gmZoom')) {\n\t        hasZoom = true;\n\t      }\n\t      if (attrs.hasOwnProperty('gmBounds')) {\n\t        hasBounds = true;\n\t      }\n\t      if (attrs.hasOwnProperty('gmMapTypeId')) {\n\t        hasMapTypeId = true;\n\t      }\n\n\t      var _updateScope = function _updateScope() {\n\t        $timeout(function () {\n\t          if (hasCenter || hasZoom || hasBounds || hasMapTypeId) {\n\t            scope.$apply(function (s) {\n\t              if (hasCenter) {\n\t                scope.gmCenter = controller.center;\n\t              }\n\t              if (hasZoom) {\n\t                scope.gmZoom = controller.zoom;\n\t              }\n\t              if (hasBounds) {\n\t                var b = controller.bounds;\n\t                if (b) {\n\t                  scope.gmBounds = b;\n\t                }\n\t              }\n\t              if (hasMapTypeId) {\n\t                scope.gmMapTypeId = controller.mapTypeId;\n\t              }\n\t            });\n\t          }\n\t        });\n\t      };\n\n\t      var updateScope = debounce(_updateScope, 100);\n\n\t      // Add event listeners to the map\n\t      controller.addMapListener('drag', updateScope);\n\t      controller.addMapListener('zoom_changed', updateScope);\n\t      controller.addMapListener('center_changed', updateScope);\n\t      controller.addMapListener('bounds_changed', updateScope);\n\t      controller.addMapListener('maptypeid_changed', updateScope);\n\t      controller.addMapListener('resize', updateScope);\n\n\t      // Add user supplied callbacks\n\t      var map = controller.getMap(attrs.gmMapId);\n\t      var handlers = getEventHandlers(attrs); // map events -> handlers\n\t      angular.forEach(handlers, function (handler, event) {\n\t        controller.addMapListener(event, function (ev) {\n\t          // pass the map in\n\t          var locals = {\n\t            map: map\n\t          };\n\t          // And optionally a MouseEvent object if it exists\n\t          if (ev !== undefined) {\n\t            locals.event = ev;\n\t          }\n\n\t          $timeout(function () {\n\t            handler(scope.$parent, locals);\n\t          });\n\t        });\n\t      });\n\n\t      if (hasCenter) {\n\t        scope.$watchCollection('gmCenter', function (newValue, oldValue) {\n\t          var changed = newValue !== oldValue;\n\t          if (changed && !controller.dragging) {\n\t            var latLng = newValue;\n\t            if (latLng) controller.center = latLng;\n\t          }\n\t        });\n\t      }\n\n\t      if (hasZoom) {\n\t        scope.$watch('gmZoom', function (newValue, oldValue) {\n\t          var ok = newValue != null && !isNaN(newValue);\n\t          if (ok && newValue !== oldValue) {\n\t            controller.zoom = newValue;\n\t          }\n\t        });\n\t      }\n\n\t      if (hasBounds) {\n\t        scope.$watch('gmBounds', function (newValue, oldValue) {\n\t          var changed = newValue !== oldValue;\n\t          if (changed && !controller.dragging) {\n\t            var bounds = newValue;\n\t            if (bounds) controller.bounds = bounds;\n\t          }\n\t        });\n\t      }\n\n\t      if (hasMapTypeId) {\n\t        scope.$watch('gmMapTypeId', function (newValue, oldValue) {\n\t          var changed = newValue !== oldValue;\n\t          if (changed && newValue) {\n\t            controller.mapTypeId = newValue;\n\t          }\n\t        });\n\t      }\n\n\t      scope.$on('gmMapResize', function (event, gmMapId) {\n\t        if (scope.gmMapId() === gmMapId) {\n\t          controller.mapTrigger('resize');\n\t        }\n\t      });\n\n\t      controller.addMapListenerOnce('idle', function () {\n\t        scope.$emit('gmMapIdle', scope.gmMapId());\n\t      });\n\t      controller.mapTrigger('resize');\n\t    }\n\n\t    return {\n\t      restrict: 'AE',\n\t      priority: 100,\n\t      template: '<div>' + '<div id=\"\" style=\"width:100%;height:100%;\"></div>' + '<div ng-transclude></div>' + '</div>',\n\t      transclude: true,\n\t      replace: true,\n\t      scope: {\n\t        gmCenter: '=',\n\t        gmZoom: '=',\n\t        gmBounds: '=',\n\t        gmMapTypeId: '=',\n\t        gmMapOptions: '&',\n\t        gmMapId: '&'\n\t      },\n\t      controller: 'angulargmMapController',\n\t      link: link\n\t    };\n\t  }]);\n\t})();\n\n\t/**\n\t * @ngdoc directive\n\t * @name angulargm.directive:gmMarkers\n\t * @element ANY\n\t *\n\t * @description\n\t * A directive for adding markers to a `gmMap`. You may have multiple per `gmMap`.\n\t *\n\t * To use, you specify an array of custom objects and tell the directive how to\n\t * extract an id and position from them. A marker will be created for each of\n\t * your objects. If you assign a new array to your scope variable or change the\n\t * array's length (i.e. add or remove an object), the markers will also update.\n\t * The one case where `gmMarkers` can not automatically detect changes to your\n\t * objects is when you mutate objects in the array. To inform the directive of\n\t * such changes, see the `gmMarkersUpdate` event below.\n\t *\n\t * Only the `gm-objects`, `gm-id` and `gm-position` attributes are required.\n\t *\n\t * @param {expression} gm-objects an array of objects in the current scope.\n\t * These can be any objects you wish to attach to markers, the only requirement\n\t * is that they have a uniform method of accessing an id and a position.\n\t *\n\t * @param {expression} gm-id an angular expression that given an object from\n\t * `gm-objects`, evaluates to a unique identifier for that object. Your object\n\t * can be accessed through the variable `object`. See `gm-position` below for\n\t * an example.\n\t *\n\t * @param {expression} gm-position an angular expression that given an object from\n\t * `gm-objects`, evaluates to an object with lat and lng properties. Your\n\t * object can be accessed through the variable `object`.  For example, if\n\t * your controller has\n\t * ```js\n\t * ...\n\t * $scope.myObjects = [\n\t *   { id: 0, location: { lat: 5, lng: 5} },\n\t *   { id: 1, location: { lat: 6, lng: 6} }\n\t * ]\n\t * ...\n\t * ```\n\t * then in the `gm-markers` directive you would put\n\t * ```js\n\t * ...\n\t * gm-objects=\"myObjects\"\n\t * gm-id=\"object.id\"\n\t * gm-position=\"{ lat: object.location.lat, lng: object.location.lng }\"\n\t * ...\n\t * ```\n\t *\n\t *\n\t * @param {expression} gm-marker-options an angular expression that given\n\t * an object from `gm-objects`, evaluates to a\n\t * [google.maps.MarkerOptions](https://developers.google.com/maps/documentation/javascript/reference#MarkerOptions)\n\t * object.  Your object can be accessed through the variable `object`. If\n\t * unspecified, google maps api defaults will be used.\n\t *\n\t *\n\t * @param {expression} gm-events a variable in the current scope that is used to\n\t * simulate events on markers. Setting this variable to an object of the form\n\t * ```js\n\t *     [\n\t *       {\n\t *         event: 'click',\n\t *         ids: [id1, ...]\n\t *       },\n\t *       ...\n\t *     ]\n\t * ```\n\t * will generate the named events on the markers with the given ids, if a\n\t * marker with each id exists. Note: when setting the `gm-events` variable, you\n\t * must set it to a new object for the changes to be detected.  Code like\n\t * ```js\n\t * myEvents[0][\"ids\"] = [0]\n\t * ```\n\t * will not work.\n\t *\n\t *\n\t * @param {expression} gm-on-*event* an angular expression which evaluates to\n\t * an event handler. This handler will be attached to each marker's \\*event\\*\n\t * event.  The variables 'object' and 'marker' evaluate to your object and the\n\t * [google.maps.Marker](https://developers.google.com/maps/documentation/javascript/reference#Marker),\n\t * respectively. For example:\n\t * ```html\n\t * gm-on-click=\"myClickFn(object, marker)\"\n\t * ```\n\t * will call your `myClickFn` whenever a marker is clicked.  You may have\n\t * multiple `gm-on-*event*` handlers, but only one for each type of event.\n\t * For events that have an underscore in their name, such as\n\t * 'position_changed', write it as 'gm-on-position-changed'.\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @name angulargm.directive:gmMarkers#gmMarkersUpdate\n\t * @eventOf angulargm.directive:gmMarkers\n\t * @eventType listen on current gmMarkers scope\n\t *\n\t * @description Manually tell the `gmMarkers` directive to update the markers.\n\t * This is useful to tell the directive when an object from `gm-objects` is\n\t * mutated--`gmMarkers` can not pick up on such changes automatically.\n\t *\n\t * @param {string} objects Not required. The name of the scope variable which\n\t * holds the objects to update markers for, i.e. what you set `gm-objects` to.\n\t * It is useful because there may be multiple instances of the `gmMarkers`\n\t * directive. If not specified, all instances of `gmMarkers` which are child\n\t * scopes will update their markers.\n\t *\n\t * @example\n\t * ```js\n\t * $scope.$broadcast('gmMarkersUpdate', 'myObjects');\n\t * ```\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @name angulargm.directive:gmMarkers#gmMarkersRedraw\n\t * @eventOf angulargm.directive:gmMarkers\n\t * @eventType listen on current gmMarkers scope\n\t *\n\t * @description Force the `gmMarkers` directive to clear and redraw all markers.\n\t *\n\t * @param {string} objects Not required. The name of the scope variable which\n\t * holds the objects to redraw markers for, i.e. what you set `gm-objects` to.\n\t * It is useful because there may be multiple instances of the `gmMarkers`\n\t * directive. If not specified, all instances of `gmMarkers` which are child\n\t * scopes will redraw their markers.\n\t *\n\t * @example\n\t * ```js\n\t * $scope.$broadcast('gmMarkersRedraw', 'myObjects');\n\t * ```\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @name angulargm.directive:gmMarkers#gmMarkersUpdated\n\t * @eventOf angulargm.directive:gmMarkers\n\t * @eventType emit on current gmMarkers scope\n\t *\n\t * @description Emitted when markers are updated.\n\t *\n\t * @param {string} objects the name of the scope variable which holds the\n\t * objects the `gmMarkers` directive was constructed with. This is what\n\t * `gm-objects` was set to.\n\t *\n\t * @example\n\t * ```js\n\t * $scope.$on('gmMarkersUpdated', function(event, objects) {\n\t *     if (objects === 'myObjects') {\n\t *       ...\n\t *     }\n\t * });\n\t * ```\n\t */\n\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').directive('gmMarkers', ['$log', '$parse', '$timeout', 'angulargmUtils', 'angulargmShape', function ($log, $parse, $timeout, angulargmUtils, angulargmShape) {\n\n\t    /** aliases */\n\t    var objToLatLng = angulargmUtils.objToLatLng;\n\n\t    function link(scope, element, attrs, controller) {\n\t      // check marker attrs\n\t      if (!('gmPosition' in attrs)) {\n\t        throw 'gmPosition attribute required';\n\t      }\n\n\t      var markerOptions = function markerOptions(object) {\n\t        var latLngObj = scope.gmPosition({ object: object });\n\t        var position = objToLatLng(latLngObj);\n\t        if (position == null) {\n\t          return null;\n\t        }\n\n\t        var markerOptions = scope.gmMarkerOptions({ object: object });\n\t        var options = {};\n\t        angular.extend(options, markerOptions, { position: position });\n\t        return options;\n\t      };\n\n\t      angulargmShape.createShapeDirective('marker', scope, attrs, controller, markerOptions);\n\t    }\n\n\t    return {\n\t      restrict: 'AE',\n\t      priority: 100,\n\t      scope: {\n\t        gmObjects: '&',\n\t        gmId: '&',\n\t        gmPosition: '&',\n\t        gmMarkerOptions: '&',\n\t        gmEvents: '&'\n\t      },\n\t      require: '^gmMap',\n\t      link: link\n\t    };\n\t  }]);\n\t})();\n\n\t/**\n\t * @ngdoc directive\n\t * @name angulargm.directive:gmPolylines\n\t * @element ANY\n\t *\n\t * @description\n\t * A directive for adding polylines to a `gmMap`. You may have multiple per `gmMap`.\n\t *\n\t * To use, you specify an array of custom objects and tell the directive how to\n\t * extract location data from them. A polyline will be created for each of your\n\t * objects. If you assign a new array to your scope variable or change the\n\t * array's length, the polylines will also update.  The one case where\n\t * `gmPolylines` can not automatically detect changes to your objects is when\n\t * you mutate objects in the array. To inform the directive of such changes,\n\t * see the `gmPolylinesUpdate` event below.\n\t *\n\t * Only the `gm-objects`, `gm-id` and `gm-path` attributes are required.\n\t *\n\t * @param {expression} gm-objects an array of objects in the current scope.\n\t * These can be any objects you wish to attach to polylines, the only requirement\n\t * is that they have a uniform method of accessing an id and a path.\n\t *\n\t * @param {expression} gm-path an angular expression that given an object\n\t * from `gm-objects`, evaluates to an array of objects with lat and lng\n\t * properties. Your object can be accessed through the variable `object`.  For\n\t * example, if your controller has\n\t * ```js\n\t * ...\n\t * $scope.myObjects = [\n\t *   { id: 0, path: [ { lat: 5, lng: 5}, {lat: 4, lng: 4} ]},\n\t *   { id: 1, path: [ { lat: 6, lng: 6}, {lat: 7, lng: 7} ]}\n\t * ]\n\t * ...\n\t * ```\n\t * then in the `gm-polylines` directive you would put\n\t * ```js\n\t * ...\n\t * gm-objects=\"myObjects\"\n\t * gm-get-path=\"object.path\"\n\t * ...\n\t * ```\n\t *\n\t * @param {expression} gm-polyline-options an angular expression that given\n\t * an object from `gm-objects`, evaluates to a\n\t * [google.maps.PolylineOptions](https://developers.google.com/maps/documentation/javascript/reference#PolylineOptions)\n\t * object.  Your object can be accessed through the variable `object`. If\n\t * unspecified, google maps api defaults will be used.\n\t *\n\t * @param {expression} gm-events a variable in the current scope that is used to\n\t * simulate events on polylines. Setting this variable to an object of the form\n\t * ```js\n\t *     [\n\t *       {\n\t *         event: 'click',\n\t *         ids: [id1, ...]\n\t *       },\n\t *       ...\n\t *     ]\n\t * ```\n\t * will generate the named events on the polylines with the given ids, if a\n\t * polyline with each id exists. Note: when setting the `gm-events` variable, you\n\t * must set it to a new object for the changes to be detected.  Code like\n\t * ```js\n\t * myEvents[0][\"ids\"] = [0]\n\t * ```\n\t * will not work.\n\t *\n\t *\n\t * @param {expression} gm-on-*event* an angular expression which evaluates to\n\t * an event handler. This handler will be attached to each polyline's \\*event\\*\n\t * event.  The variables 'object' and 'polyline' evaluate to your object and the\n\t * [google.maps.Polyline](https://developers.google.com/maps/documentation/javascript/reference#Polyline),\n\t * respectively. For example:\n\t * ```html\n\t * gm-on-click=\"myClickFn(object, polyline)\"\n\t * ```\n\t * will call your `myClickFn` whenever a polyline is clicked.  You may have\n\t * multiple `gm-on-*event*` handlers, but only one for each type of event.\n\t * For events that have an underscore in their name, such as\n\t * 'position_changed', write it as 'gm-on-position-changed'.\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @name angulargm.directive:gmPolylines#gmPolylinesUpdate\n\t * @eventOf angulargm.directive:gmPolylines\n\t * @eventType listen on current gmPolylines scope\n\t *\n\t * @description Manually tell the `gmPolylines` directive to update the polylines.\n\t * This is useful to tell the directive when an object from `gm-objects` is\n\t * mutated--`gmPolylines` can not pick up on such changes automatically.\n\t *\n\t * @param {string} objects Not required. The name of the scope variable which\n\t * holds the objects to update polylines for, i.e. what you set `gm-objects` to.\n\t * It is useful because there may be multiple instances of the `gmPolylines`\n\t * directive. If not specified, all instances of `gmPolylines` which are child\n\t * scopes will update their polylines.\n\t *\n\t * @example\n\t * ```js\n\t * $scope.$broadcast('gmPolylinesUpdate', 'myObjects');\n\t * ```\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @name angulargm.directive:gmPolylines#gmPolylinesRedraw\n\t * @eventOf angulargm.directive:gmPolylines\n\t * @eventType listen on current gmPolylines scope\n\t *\n\t * @description Force the gmPolylines directive to clear and redraw all polylines.\n\t *\n\t * @param {string} objects Not required. The name of the scope variable which\n\t * holds the objects to redraw polylines for, i.e. what you set `gm-objects` to.\n\t * It is useful because there may be multiple instances of the `gmPolylines`\n\t * directive. If not specified, all instances of gmPolylines which are child\n\t * scopes will redraw their polylines.\n\t *\n\t * @example\n\t * ```js\n\t * $scope.$broadcast('gmPolylinesRedraw', 'myObjects');\n\t * ```\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @name angulargm.directive:gmPolylines#gmPolylinesUpdated\n\t * @eventOf angulargm.directive:gmPolylines\n\t * @eventType emit on current gmPolylines scope\n\t *\n\t * @description Emitted when polylines are updated.\n\t *\n\t * @param {string} objects the name of the scope variable which holds the\n\t * objects the gmPolylines directive was constructed with. This is what\n\t * `gm-objects` was set to.\n\t *\n\t * @example\n\t * ```js\n\t * $scope.$on('gmPolylinesUpdated', function(event, objects) {\n\t *     if (objects === 'myObjects') {\n\t *       ...\n\t *     }\n\t * });\n\t * ```\n\t */\n\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').directive('gmPolylines', ['$parse', '$compile', '$timeout', '$log', 'angulargmUtils', 'angulargmShape', function ($parse, $compile, $timeout, $log, angulargmUtils, angulargmShape) {\n\t    /** aliases */\n\t    var objToLatLng = angulargmUtils.objToLatLng;\n\n\t    function link(scope, element, attrs, controller) {\n\t      if (!('gmPath' in attrs)) {\n\t        throw 'gmPath attribute required';\n\t      }\n\n\t      var polylineOptions = function polylineOptions(object) {\n\t        var lineLatLngs = scope.gmPath({ object: object });\n\t        var path = [];\n\n\t        angular.forEach(lineLatLngs, function (latlng) {\n\t          var position = objToLatLng(latlng);\n\t          if (position == null) {\n\t            $log.warn('Unable to generate lat/lng from ', latlng);\n\t            return;\n\t          }\n\t          path.push(position);\n\t        });\n\n\t        var polylineOptions = scope.gmPolylineOptions({ object: object });\n\t        var options = {};\n\t        angular.extend(options, polylineOptions, { path: path });\n\t        return options;\n\t      };\n\n\t      angulargmShape.createShapeDirective('polyline', scope, attrs, controller, polylineOptions);\n\t    }\n\n\t    return {\n\t      restrict: 'AE',\n\t      priority: 100,\n\t      scope: {\n\t        gmObjects: '&',\n\t        gmId: '&',\n\t        gmPath: '&',\n\t        gmPolylineOptions: '&',\n\t        gmEvents: '&'\n\t      },\n\t      require: '^gmMap',\n\t      link: link\n\t    };\n\t  }]);\n\t})();\n\n\t/**\n\t * @ngdoc service\n\t * @name angulargm.service:angulargmContainer\n\t *\n\t * @description\n\t * A container which maps mapIds to google.maps.Map instances, and additionally\n\t * allows getting a promise of a map for custom configuration of the map.\n\t *\n\t * If you want a handle to the map, you should use the `getMapPromise(mapId)`\n\t * method so you can guarantee the map will be initialized. For example,\n\t *\n\t * ```js\n\t * angular.module('myModule').\n\t *\n\t * run(function(angulargmContainer) {\n\t *   var gmapPromise = angulargmContainer.getMapPromise('myMapid');\n\t *\n\t *   gmapPromise.then(function(gmap) {\n\t *     // google map configuration here\n\t *   });\n\t * });\n\t * ```\n\t */\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').factory('angulargmContainer', ['$q', function ($q) {\n\t    var maps = {};\n\t    var defers = {};\n\n\t    /**\n\t     * Add a map to the container.\n\t     * @param {string} mapId the unique identifier for the map\n\t     * @param {google.maps.Map} map the google map\n\t     * @throw if there is already a map with mapId, or if map is not a\n\t     *   google.maps.Map\n\t     */\n\t    function addMap(mapId, map) {\n\t      if (!(map instanceof google.maps.Map)) {\n\t        throw 'map not a google.maps.Map: ' + map;\n\t      } else if (mapId in maps) {\n\t        throw 'already contain map with id ' + mapId;\n\t      }\n\t      maps[mapId] = map;\n\t      if (mapId in defers) {\n\t        defers[mapId].resolve(map);\n\t      }\n\t    }\n\n\t    /**\n\t     * Get a map from the container.\n\t     * @param {string} mapId the unique id of the map\n\t     * @return {google.maps.Map|undefined} the map, or undefined if there is no\n\t     *   map for mapId\n\t     */\n\t    function getMap(mapId) {\n\t      return maps[mapId];\n\t    }\n\n\t    /**\n\t     * Returns a promise of a map for the given mapId\n\t     * @param {string} mapId the unique id of the map that may or may not have\n\t     *   been created yet\n\t     * @return {angular.q.promise} a promise of a map that will be resolved\n\t     *   when the map is added\n\t     */\n\t    function getMapPromise(mapId) {\n\t      var defer = defers[mapId] || $q.defer();\n\t      var map = getMap(mapId);\n\t      defers[mapId] = defer;\n\t      if (map !== undefined) {\n\t        defer.resolve(map);\n\t      }\n\t      return defer.promise;\n\t    }\n\n\t    /**\n\t     * Removes map with given mapId from this container, and deletes the map.\n\t     * In order for this to work you must ensure there are no references to the\n\t     * map object. Note: this will likely cause a memory leak, see\n\t     * http://stackoverflow.com/questions/10485582/what-is-the-proper-way-to-destroy-a-map-instance\n\t     *\n\t     * @param {string} mapId the unique id of the map to remove\n\t     */\n\t    function removeMap(mapId) {\n\t      if (mapId in maps) {\n\t        delete maps[mapId];\n\t      }\n\t      if (mapId in defers) {\n\t        delete defers[mapId];\n\t      }\n\t    }\n\n\t    /**\n\t     * Removes all maps and unresolved map promises. Only for testing, see\n\t     * #removeMap(mapId).\n\t     */\n\t    function clear() {\n\t      maps = {};\n\t      defers = {};\n\t    }\n\n\t    return {\n\t      addMap: addMap,\n\t      getMap: getMap,\n\t      getMapPromise: getMapPromise,\n\t      removeMap: removeMap,\n\t      clear: clear\n\t    };\n\t  }]);\n\t})();\n\n\t/**\n\t * @ngdoc service\n\t * @name angulargm.service:angulargmShape\n\t *\n\t * @description\n\t * Directive functions for map shapes (marker, polyline, etc.)\n\t */\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').factory('angulargmShape', ['$timeout', 'angulargmUtils', function ($timeout, angulargmUtils) {\n\n\t    /**\n\t     * Check required attributes of a shape.\n\t     */\n\t    function checkRequiredAttributes(attrs) {\n\t      if (!('gmObjects' in attrs)) {\n\t        throw 'gmObjects attribute required';\n\t      } else if (!('gmId' in attrs)) {\n\t        throw 'gmId attribute required';\n\t      }\n\t    }\n\n\t    /**\n\t     * Create a mapping from object id -> object.\n\t     * The object id is retrieved using scope.gmId\n\t     */\n\t    function _generateObjectCache(scope, objects) {\n\t      var objectCache = {};\n\t      angular.forEach(objects, function (object) {\n\t        // cache objects for quick access\n\t        var id = scope.gmId({ object: object });\n\t        objectCache[id] = object;\n\t      });\n\t      return objectCache;\n\t    }\n\n\t    /**\n\t     * Create new shapes and add them to the map for objects which are not\n\t     * currently on the map.\n\t     */\n\t    function _addNewElements(type, scope, controller, handlers, objectCache, optionsFn) {\n\t      angular.forEach(objectCache, function (object, id) {\n\t        var element = controller.getElement(type, scope.$id, id);\n\n\t        var options = optionsFn(object);\n\t        if (options == null) {\n\t          return;\n\t        }\n\n\t        if (element) {\n\t          controller.updateElement(type, scope.$id, id, options);\n\t        } else {\n\t          controller.addElement(type, scope.$id, id, options);\n\t          element = controller.getElement(type, scope.$id, id);\n\n\t          // set up element event handlers\n\t          angular.forEach(handlers, function (handler, event) {\n\t            controller.addListener(element, event, function () {\n\t              $timeout(function () {\n\t                var context = { object: object };\n\t                context[type] = element;\n\t                if (angular.version.major <= 1 && angular.version.minor <= 2) {\n\t                  // scope is this directive's isolate scope\n\t                  // scope.$parent is the scope of ng-transclude\n\t                  // scope.$parent.$parent is the one we want\n\t                  handler(scope.$parent.$parent, context);\n\t                } else {\n\t                  handler(scope.$parent.$parent.$parent, context);\n\t                }\n\t              });\n\t            });\n\t          });\n\t        }\n\t      });\n\t    }\n\n\t    /**\n\t     * Remove shape elements from the map which are no longer in objects.\n\t     */\n\t    function _removeOrphanedElements(type, scope, controller, objectCache) {\n\t      var orphaned = [];\n\n\t      controller.forEachElementInScope(type, scope.$id, function (element, id) {\n\t        if (!(id in objectCache)) {\n\t          orphaned.push(id);\n\t        }\n\t      });\n\n\t      angular.forEach(orphaned, function (id) {\n\t        controller.removeElement(type, scope.$id, id);\n\t      });\n\t    }\n\n\t    /**\n\t     * _formatEventName('gmShapesUpdated', 'marker') -> 'gmMarkersUpdated'\n\t     */\n\t    function _formatEventName(template, type) {\n\t      var uppercasePluralType = type.charAt(0).toUpperCase() + type.slice(1) + 's';\n\t      return template.replace('Shapes', uppercasePluralType);\n\t    }\n\n\t    /**\n\t     * Attach necessary watchers and listeners to scope to deal with:\n\t     * - updating objects\n\t     * - handling gmEvents\n\t     * - listening for events\n\t     */\n\t    function _attachEventListeners(type, scope, attrs, controller, updateElements) {\n\n\t      // watch objects\n\t      scope.$watch('gmObjects().length', function (newValue, oldValue) {\n\t        if (newValue != null && newValue !== oldValue) {\n\t          updateElements(scope, scope.gmObjects());\n\t        }\n\t      });\n\n\t      scope.$watch('gmObjects()', function (newValue, oldValue) {\n\t        if (newValue != null && newValue !== oldValue) {\n\t          updateElements(scope, scope.gmObjects());\n\t        }\n\t      });\n\n\t      // watch gmEvents\n\t      scope.$watch('gmEvents()', function (newValue, oldValue) {\n\t        if (newValue != null && newValue !== oldValue) {\n\t          angular.forEach(newValue, function (eventObj) {\n\t            var event = eventObj.event;\n\t            var ids = eventObj.ids;\n\t            angular.forEach(ids, function (id) {\n\t              var element = controller.getElement(type, scope.$id, id);\n\t              if (element != null) {\n\t                $timeout(angular.bind(this, controller.trigger, element, event));\n\t              }\n\t            });\n\t          });\n\t        }\n\t      });\n\n\t      scope.$on(_formatEventName('gmShapesRedraw', type), function (event, objectsName) {\n\t        if (objectsName == null || objectsName === attrs.gmObjects) {\n\t          updateElements(scope);\n\t          updateElements(scope, scope.gmObjects());\n\t        }\n\t      });\n\n\t      scope.$on(_formatEventName('gmShapesUpdate', type), function (event, objectsName) {\n\t        if (objectsName == null || objectsName === attrs.gmObjects) {\n\t          updateElements(scope, scope.gmObjects());\n\t        }\n\t      });\n\t    }\n\n\t    /**\n\t     * Takes care of setting up the directive for the given type of shape.\n\t     * Assumes the following directive scope:\n\t     *   scope: {\n\t     *     gmId: '&',\n\t     *     gmObjects: '&',\n\t     *     gmEvents: '&'\n\t     *   },\n\t     *\n\t     * And the angulargmMapController:\n\t     *   require: '^gmMap',\n\t     *\n\t     * Also supports the following attributes:\n\t     *   gmOn* (though some of this knowledge is in angulargmUtils as well)\n\t     *\n\t     * As well as the following events\n\t     *   gmShapesUpdated\n\t     *   gmShapesRedraw\n\t     *\n\t     * (e.g. gmMarkersUpdated and gmMarkersRedraw)\n\t     *\n\t     * See gmMarkers for a complete example.\n\t     */\n\t    function createShapeDirective(type, scope, attrs, controller, elementOptions) {\n\t      checkRequiredAttributes(attrs);\n\n\t      var updateElements = function updateElements(scope, objects) {\n\t        var objectCache = _generateObjectCache(scope, objects);\n\t        var handlers = angulargmUtils.getEventHandlers(attrs); // map events -> handlers\n\n\t        _addNewElements(type, scope, controller, handlers, objectCache, elementOptions);\n\n\t        _removeOrphanedElements(type, scope, controller, objectCache);\n\n\t        scope.$emit(_formatEventName('gmShapesUpdated', type), attrs.gmObjects);\n\t      };\n\n\t      _attachEventListeners(type, scope, attrs, controller, updateElements);\n\n\t      // initialize elements\n\t      $timeout(angular.bind(null, updateElements, scope, scope.gmObjects()));\n\t    }\n\n\t    return {\n\t      createShapeDirective: createShapeDirective\n\t    };\n\t  }]);\n\t})();\n\n\t/**\n\t * @ngdoc service\n\t * @name angulargm.service:angulargmUtils\n\t *\n\t * @description\n\t * Common utility functions.\n\t */\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').factory('angulargmUtils', ['$parse', function ($parse) {\n\n\t    /**\n\t     * Check if two floating point numbers are equal.\n\t     *\n\t     * @param {number} f1 first number\n\t     * @param {number} f2 second number\n\t     * @return {boolean} true if f1 and f2 are 'very close' (within 0.000001)\n\t     */\n\t    function floatEqual(f1, f2) {\n\t      return Math.abs(f1 - f2) < 0.000001;\n\t    }\n\n\t    /**\n\t     * @ngdoc function\n\t     * @name #latLngEqual\n\t     * @methodOf angulargm.service:angulargmUtils\n\t     *\n\t     * @param {google.maps.LatLng} l1 first\n\t     * @param {google.maps.LatLng} l2 second\n\t     * @return {boolean} true if l1 and l2 are 'very close'. If either are null\n\t     * or not google.maps.LatLng objects returns false.\n\t     */\n\t    function latLngEqual(l1, l2) {\n\t      if (!(l1 instanceof google.maps.LatLng && l2 instanceof google.maps.LatLng)) {\n\t        return false;\n\t      }\n\t      return floatEqual(l1.lat(), l2.lat()) && floatEqual(l1.lng(), l2.lng());\n\t    }\n\n\t    /**\n\t     * @ngdoc function\n\t     * @name #boundsEqual\n\t     * @methodOf angulargm.service:angulargmUtils\n\t     *\n\t     * @param {google.maps.LatLngBounds} b1 first\n\t     * @param {google.maps.LatLngBounds} b2 second\n\t     * @return {boolean} true if b1 and b2 are 'very close'. If either are null\n\t     * or not google.maps.LatLngBounds objects returns false.\n\t     */\n\t    function boundsEqual(b1, b2) {\n\t      if (!(b1 instanceof google.maps.LatLngBounds && b2 instanceof google.maps.LatLngBounds)) {\n\t        return false;\n\t      }\n\t      var sw1 = b1.getSouthWest();\n\t      var sw2 = b2.getSouthWest();\n\t      var ne1 = b1.getNorthEast();\n\t      var ne2 = b2.getNorthEast();\n\n\t      return latLngEqual(sw1, sw2) && latLngEqual(ne1, ne2);\n\t    }\n\n\t    /**\n\t     * @ngdoc function\n\t     * @name #latLngToObj\n\t     * @methodOf angulargm.service:angulargmUtils\n\t     *\n\t     * @param {google.maps.LatLng} latLng the LatLng\n\t     * @return {Object} object literal with 'lat' and 'lng' properties.\n\t     * @throw if latLng not instanceof google.maps.LatLng\n\t     */\n\t    function latLngToObj(latLng) {\n\t      if (!(latLng instanceof google.maps.LatLng)) throw 'latLng not a google.maps.LatLng';\n\n\t      return {\n\t        lat: latLng.lat(),\n\t        lng: latLng.lng()\n\t      };\n\t    }\n\n\t    /**\n\t     * @ngdoc function\n\t     * @name #objToLatLng\n\t     * @methodOf angulargm.service:angulargmUtils\n\t     *\n\t     * @param {Object} obj of the form { lat: 40, lng: -120 }\n\t     * @return {google.maps.LatLng} returns null if problems with obj (null,\n\t     * NaN, etc.)\n\t     */\n\t    function objToLatLng(obj) {\n\t      if (obj != null) {\n\t        var lat = obj.lat;\n\t        var lng = obj.lng;\n\t        var ok = !(lat == null || lng == null) && !(isNaN(lat) || isNaN(lng));\n\t        if (ok) {\n\t          return new google.maps.LatLng(lat, lng);\n\t        }\n\t      }\n\t      return null;\n\t    }\n\n\t    /**\n\t     * @ngdoc function\n\t     * @name #hasNaN\n\t     * @methodOf angulargm.service:angulargmUtils\n\t     *\n\t     * @param {google.maps.LatLng} latLng the LatLng\n\t     * @return {boolean} true if either lat or lng of latLng is null or isNaN\n\t     */\n\t    function hasNaN(latLng) {\n\t      if (!(latLng instanceof google.maps.LatLng)) throw 'latLng must be a google.maps.LatLng';\n\n\t      // google.maps.LatLng converts NaN to null, so check for both\n\t      var isNull = latLng.lat() == null || latLng.lng() == null;\n\t      var isNotaN = isNaN(latLng.lat()) || isNaN(latLng.lng());\n\t      return isNull || isNotaN;\n\t    }\n\n\t    /**\n\t     * @param {Object} attrs directive attributes\n\t     * @return {Object} mapping from event names to handler fns\n\t     */\n\t    function getEventHandlers(attrs) {\n\t      var handlers = {};\n\n\t      // retrieve gm-on-___ handlers\n\t      angular.forEach(attrs, function (value, key) {\n\t        if (key.lastIndexOf('gmOn', 0) === 0) {\n\t          var event = angular.lowercase(key.substring(4).replace(/(?!^)([A-Z])/g, '_$&'));\n\t          var fn = $parse(value);\n\t          handlers[event] = fn;\n\t        }\n\t      });\n\n\t      return handlers;\n\t    }\n\n\t    function assertDefined(value, name) {\n\t      if (value === undefined || value === null) {\n\t        if (name) {\n\t          throw name + ' was: ' + value;\n\t        } else {\n\t          throw 'value was: ' + value;\n\t        }\n\t      }\n\t    }\n\n\t    return {\n\t      latLngEqual: latLngEqual,\n\t      boundsEqual: boundsEqual,\n\t      latLngToObj: latLngToObj,\n\t      objToLatLng: objToLatLng,\n\t      hasNaN: hasNaN,\n\t      getEventHandlers: getEventHandlers,\n\t      assertDefined: assertDefined\n\t    };\n\t  }]);\n\t})();\n\n\t/**\n\t * @ngdoc service\n\t * @name angulargm.service:debounce\n\t *\n\t * @description\n\t * Debounce function. Stolen from https://github.com/shahata/angular-debounce\n\t */\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').factory('debounce', ['$timeout', function ($timeout) {\n\t    return function (func, wait, immediate) {\n\t      var timeout, args, context, result;\n\t      function debounce() {\n\t        /* jshint validthis:true */\n\t        context = this;\n\t        args = arguments;\n\t        var later = function later() {\n\t          timeout = null;\n\t          if (!immediate) {\n\t            result = func.apply(context, args);\n\t          }\n\t        };\n\t        var callNow = immediate && !timeout;\n\t        if (timeout) {\n\t          $timeout.cancel(timeout);\n\t        }\n\t        timeout = $timeout(later, wait);\n\t        if (callNow) {\n\t          result = func.apply(context, args);\n\t        }\n\t        return result;\n\t      }\n\t      debounce.cancel = function () {\n\t        $timeout.cancel(timeout);\n\t        timeout = null;\n\t      };\n\t      return debounce;\n\t    };\n\t  }]);\n\t})();\n\n\t/**\n\t * Directive controller which is owned by the [gmMap]{@link module:gmMap}\n\t * directive and shared among all other angulargm directives.\n\t */\n\t(function () {\n\t  'use strict';\n\n\t  angular.module('AngularGM').controller('angulargmMapController', ['$scope', '$element', 'angulargmUtils', 'angulargmDefaults', 'angulargmContainer', function ($scope, $element, angulargmUtils, angulargmDefaults, angulargmContainer) {\n\n\t    /** aliases */\n\t    var latLngEqual = angulargmUtils.latLngEqual;\n\t    var boundsEqual = angulargmUtils.boundsEqual;\n\t    var hasNaN = angulargmUtils.hasNaN;\n\t    var assertDefined = angulargmUtils.assertDefined;\n\n\t    /*\n\t     * Construct a new controller for the gmMap directive.\n\t     * @param {angular.Scope} $scope\n\t     * @param {angular.element} $element\n\t     * @constructor\n\t     */\n\t    var constructor = function constructor($scope, $element) {\n\n\t      var mapId = $scope.gmMapId();\n\t      if (!mapId) {\n\t        throw 'angulargm must have non-empty gmMapId attribute';\n\t      }\n\n\t      var mapDiv = angular.element($element[0].firstChild);\n\t      mapDiv.attr('id', mapId);\n\n\t      var config = this._getConfig($scope, angulargmDefaults);\n\n\t      // 'private' properties\n\t      this._map = this._createMap(mapId, mapDiv, config, angulargmContainer, $scope);\n\t      this._elements = {};\n\t      this._listeners = {};\n\n\t      // 'public' properties\n\t      this.dragging = false;\n\n\t      Object.defineProperties(this, {\n\t        'precision': {\n\t          value: angulargmDefaults.precision,\n\t          writeable: false\n\t        },\n\n\t        'center': {\n\t          configurable: true, // for testing so we can mock\n\t          get: function get() {\n\t            return this._map.getCenter();\n\t          },\n\t          set: function set(center) {\n\t            if (hasNaN(center)) throw 'center contains null or NaN';\n\t            var changed = !latLngEqual(this.center, center);\n\t            if (changed) {\n\t              this._map.panTo(center);\n\t            }\n\t          }\n\t        },\n\n\t        'zoom': {\n\t          configurable: true, // for testing so we can mock\n\t          get: function get() {\n\t            return this._map.getZoom();\n\t          },\n\t          set: function set(zoom) {\n\t            if (!(zoom != null && !isNaN(zoom))) throw 'zoom was null or NaN';\n\t            var changed = this.zoom !== zoom;\n\t            if (changed) {\n\t              this._map.setZoom(zoom);\n\t            }\n\t          }\n\t        },\n\n\t        'bounds': {\n\t          configurable: true, // for testing so we can mock\n\t          get: function get() {\n\t            return this._map.getBounds();\n\t          },\n\t          set: function set(bounds) {\n\t            var numbers = !hasNaN(bounds.getSouthWest()) && !hasNaN(bounds.getNorthEast());\n\t            if (!numbers) throw 'bounds contains null or NaN';\n\n\t            var changed = !boundsEqual(this.bounds, bounds);\n\t            if (changed) {\n\t              this._map.fitBounds(bounds);\n\t            }\n\t          }\n\t        },\n\n\t        'mapTypeId': {\n\t          configurable: true, // for testing so we can mock\n\t          get: function get() {\n\t            return this._map.getMapTypeId();\n\t          },\n\t          set: function set(mapTypeId) {\n\t            if (mapTypeId == null) throw 'mapTypeId was null or unknown';\n\t            var changed = this.mapTypeId !== mapTypeId;\n\t            if (changed) {\n\t              this._map.setMapTypeId(mapTypeId);\n\t            }\n\t          }\n\t        }\n\t      });\n\n\t      this._initDragListeners();\n\t      $scope.$on('$destroy', angular.bind(this, this._destroy));\n\t    };\n\n\t    // Retrieve google.maps.MapOptions\n\t    this._getConfig = function ($scope, angulargmDefaults) {\n\t      // Get config or defaults\n\t      var defaults = angulargmDefaults.mapOptions;\n\t      var config = {};\n\t      angular.extend(config, defaults, $scope.gmMapOptions());\n\t      return config;\n\t    };\n\n\t    // Create the map and add to angulargmContainer\n\t    this._createMap = function (id, element, config, angulargmContainer) {\n\t      var map = angulargmContainer.getMap(id);\n\t      if (!map) {\n\t        map = new google.maps.Map(element[0], config);\n\t        angulargmContainer.addMap(id, map);\n\t      } else {\n\t        var div = map.getDiv();\n\t        element.replaceWith(div);\n\t        this._map = map;\n\t        this.mapTrigger('resize');\n\t        map.setOptions(config);\n\t      }\n\t      return map;\n\t    };\n\n\t    // Set up listeners to update this.dragging\n\t    this._initDragListeners = function () {\n\t      var self = this;\n\t      this.addMapListener('dragstart', function () {\n\t        self.dragging = true;\n\t      });\n\n\t      this.addMapListener('idle', function () {\n\t        self.dragging = false;\n\t      });\n\t    };\n\n\t    this._destroy = function () {\n\t      angular.forEach(this._listeners, function (listener) {\n\t        angular.forEach(listener, function (l) {\n\t          google.maps.event.removeListener(l);\n\t        });\n\t      });\n\t      this._listeners = {};\n\n\t      var self = this;\n\t      var types = Object.keys(this._elements);\n\t      angular.forEach(types, function (type) {\n\t        var scopeIds = Object.keys(self._getElements(type));\n\t        angular.forEach(scopeIds, function (scopeId) {\n\t          self.forEachElementInScope(type, scopeId, function (element, id) {\n\t            self.removeElement(type, scopeId, id);\n\t          });\n\t        });\n\t      });\n\n\t      var streetView = this._map.getStreetView();\n\t      if (streetView && streetView.getVisible()) {\n\t        streetView.setVisible(false);\n\t      }\n\t    };\n\n\t    /**\n\t     * Alias for google.maps.event.addListener(map, event, handler)\n\t     * @param {string} event an event defined on google.maps.Map\n\t     * @param {Function} a handler for the event\n\t     */\n\t    this.addMapListener = function (event, handler) {\n\t      var listener = google.maps.event.addListener(this._map, event, handler);\n\n\t      if (this._listeners[event] === undefined) {\n\t        this._listeners[event] = [];\n\t      }\n\n\t      this._listeners[event].push(listener);\n\t    };\n\n\t    /**\n\t     * Alias for google.maps.event.addListenerOnce(map, event, handler)\n\t     * @param {string} event an event defined on google.maps.Map\n\t     * @param {Function} a handler for the event\n\t     */\n\t    this.addMapListenerOnce = function (event, handler) {\n\t      var listener = google.maps.event.addListenerOnce(this._map, event, handler);\n\n\t      if (this._listeners[event] === undefined) {\n\t        this._listeners[event] = [];\n\t      }\n\n\t      this._listeners[event].push(listener);\n\t    };\n\n\t    /**\n\t     * Alias for google.maps.event.addListener(object, event, handler)\n\t     */\n\t    this.addListener = function (object, event, handler) {\n\t      google.maps.event.addListener(object, event, handler);\n\t    };\n\n\t    /**\n\t     * Alias for google.maps.event.addListenerOnce(object, event, handler)\n\t     */\n\t    this.addListenerOnce = function (object, event, handler) {\n\t      google.maps.event.addListenerOnce(object, event, handler);\n\t    };\n\n\t    /**\n\t     * Alias for google.maps.event.trigger(map, event)\n\t     * @param {string} event an event defined on google.maps.Map\n\t     */\n\t    this.mapTrigger = function (event) {\n\t      google.maps.event.trigger(this._map, event);\n\t    };\n\n\t    /**\n\t     * Alias for google.maps.event.trigger(object, event)\n\t     */\n\t    this.trigger = function (object, event) {\n\t      google.maps.event.trigger(object, event);\n\t    };\n\n\t    this._newElement = function (type, opts) {\n\t      if (type === 'marker') {\n\t        if (!(opts.position instanceof google.maps.LatLng)) {\n\t          throw 'markerOptions did not contain a position';\n\t        }\n\t        return new angulargmDefaults.markerConstructor(opts);\n\t      } else if (type === 'polyline') {\n\t        if (!(opts.path instanceof Array)) {\n\t          throw 'polylineOptions did not contain a path';\n\t        }\n\t        return new angulargmDefaults.polylineConstructor(opts);\n\t      } else if (type === 'circle') {\n\t        if (!(opts.center instanceof google.maps.LatLng)) {\n\t          throw 'circleOptions did not contain a marker position';\n\t        }\n\t        return new angulargmDefaults.circleConstructor(opts);\n\t      } else {\n\t        throw 'unrecognized type ' + type;\n\t      }\n\t    };\n\n\t    this._getElements = function (type) {\n\t      if (!(type in this._elements)) {\n\t        this._elements[type] = {};\n\t      }\n\t      return this._elements[type];\n\t    };\n\n\t    /**\n\t     * Adds a new element to the map.\n\t     * @return {boolean} true if an element was added, false if there was already\n\t     *   an element with the given id\n\t     * @throw if any arguments are null/undefined or elementOptions does not\n\t     *   have all the required options (i.e. position)\n\t     */\n\t    this.addElement = function (type, scopeId, id, elementOptions) {\n\t      assertDefined(type, 'type');\n\t      assertDefined(scopeId, 'scopeId');\n\t      assertDefined(id, 'id');\n\t      assertDefined(elementOptions, 'elementOptions');\n\n\t      if (this.hasElement(type, scopeId, id)) {\n\t        return false;\n\t      }\n\n\t      var elements = this._getElements(type);\n\t      if (elements[scopeId] == null) {\n\t        elements[scopeId] = {};\n\t      }\n\n\t      // google maps munges passed in options, so copy it first\n\t      // extend instead of copy to preserve value objects\n\t      var opts = {};\n\t      angular.extend(opts, elementOptions);\n\t      var element = this._newElement(type, opts);\n\t      elements[scopeId][id] = element;\n\t      element.setMap(this._map);\n\n\t      return true;\n\t    };\n\n\t    /**\n\t     * Updates an element on the map with new options.\n\t     * @return {boolean} true if an element was updated, false if there was no\n\t     *   element with the given id to update\n\t     * @throw if any arguments are null/undefined or elementOptions does not\n\t     *   have all the required options (i.e. position)\n\t     */\n\n\t    this.updateElement = function (type, scopeId, id, elementOptions) {\n\t      assertDefined(type, 'type');\n\t      assertDefined(scopeId, 'scopeId');\n\t      assertDefined(id, 'id');\n\t      assertDefined(elementOptions, 'elementOptions');\n\n\t      var element = this.getElement(type, scopeId, id);\n\t      if (element) {\n\t        element.setOptions(elementOptions);\n\t        return true;\n\t      } else {\n\t        return false;\n\t      }\n\t    };\n\n\t    this.hasElement = function (type, scopeId, id) {\n\t      assertDefined(type, 'type');\n\t      assertDefined(scopeId, 'scopeId');\n\t      assertDefined(id, 'id');\n\t      return this.getElement(type, scopeId, id) != null;\n\t    };\n\n\t    /**\n\t     * @return {google maps element} the element with the given id, or null if no\n\t     *   such element exists\n\t     */\n\t    this.getElement = function (type, scopeId, id) {\n\t      assertDefined(type, 'type');\n\t      assertDefined(scopeId, 'scopeId');\n\t      assertDefined(id, 'id');\n\n\t      var elements = this._getElements(type);\n\t      if (elements[scopeId] != null && id in elements[scopeId]) {\n\t        return elements[scopeId][id];\n\t      } else {\n\t        return null;\n\t      }\n\t    };\n\n\t    /**\n\t     * @return {boolean} true if an element was removed, false if nothing\n\t     *   happened\n\t     */\n\t    this.removeElement = function (type, scopeId, id) {\n\t      assertDefined(type, 'type');\n\t      assertDefined(scopeId, 'scopeId');\n\t      assertDefined(id, 'id');\n\n\t      var elements = this._getElements(type);\n\t      var removed = false;\n\t      var element = elements[scopeId][id];\n\t      if (element) {\n\t        element.setMap(null);\n\t        removed = true;\n\t      }\n\t      elements[scopeId][id] = null;\n\t      delete elements[scopeId][id];\n\t      return removed;\n\t    };\n\n\t    /**\n\t     * Applies a function to each element on the map.\n\t     * @param {String} type of element, e.g. 'marker'\n\t     * @param {Function} fn will be called with element as first argument\n\t     * @throw if an argument is null or undefined\n\t     */\n\t    this.forEachElement = function (type, fn) {\n\t      assertDefined(type, 'type');\n\t      assertDefined(fn, 'fn');\n\n\t      var elements = this._getElements(type);\n\t      var scopeIds = Object.keys(elements);\n\t      var allElements = scopeIds.reduce(function (accumulator, scopeId) {\n\t        angular.forEach(elements[scopeId], function (element) {\n\t          accumulator.push(element);\n\t        });\n\t        return accumulator;\n\t      }, []);\n\n\t      angular.forEach(allElements, function (element, id) {\n\t        if (element != null) {\n\t          fn(element, id);\n\t        }\n\t      });\n\t    };\n\n\t    /**\n\t     * Applies a function to each element in a scope.\n\t     * @param {String} type of element, e.g. 'marker'\n\t     * @param {number} scope id\n\t     * @param {Function} fn will called with marker as first argument\n\t     * @throw if an argument is null or undefined\n\t     */\n\t    this.forEachElementInScope = function (type, scopeId, fn) {\n\t      assertDefined(type, 'type');\n\t      assertDefined(scopeId, 'scopeId');\n\t      assertDefined(fn, 'fn');\n\n\t      var elements = this._getElements(type);\n\t      angular.forEach(elements[scopeId], function (element, id) {\n\t        if (element != null) {\n\t          fn(element, id);\n\t        }\n\t      });\n\t    };\n\n\t    this.getMap = function () {\n\t      return this._map;\n\t    };\n\n\t    /** Instantiate controller */\n\t    angular.bind(this, constructor)($scope, $element);\n\t  }]);\n\t})();\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\t    'use strict';\n\n\t    exports.lpPlacesUtils = {\n\t        maxLengthLabel: 3, // Marker's label maximum size\n\t        markerColorPool: ['#FF8355', '#6FADD4', '#E69215', '#74AED3', '#C73935', '#443647', '#38706D', '#1D415B'],\n\t        markerWidth: 25,\n\t        markerHeight: 35,\n\t        markerFontFamily: 'Arial',\n\t        titleField: 'name', // Field used as title on the marker\n\t        alertTimeout: 5000, // Milliseconds until an alert will auto-close,\n\t        isCanvasSupported: function isCanvasSupported() {\n\t            return !!document.createElement('canvas').getContext;\n\t        },\n\t        maps: window.google && window.google.maps\n\n\t    };\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\t    'use strict';\n\n\t    // @ngInject\n\n\t    exports.lpPlaces = function (lpPlacesUtils) {\n\n\t        // Darw a canvas pin\n\t        var drawPin = function drawPin(context, width, height) {\n\t            var radius = width / 2;\n\t            context.beginPath();\n\t            context.moveTo(radius, height);\n\t            context.arc(radius, radius, radius, 0, Math.PI, true);\n\t            context.closePath();\n\t            context.fill();\n\t            context.stroke();\n\t        };\n\n\t        this.getFilterOptions = function (data) {\n\n\t            var types = data.types || [],\n\t                services = data.services || [];\n\n\t            return types.concat(services);\n\t        };\n\n\t        // Get url for a google pin with custom letter and color\n\t        this.googleIcon = function (label, color) {\n\t            if (color.charAt(0) === '#') {\n\t                color = color.substring(1);\n\t            }\n\t            return '//chart.apis.google.com/chart?chst=d_map_pin_letter&chld=' + label.charAt(0) + '|' + (color || 'FF0000');\n\t        };\n\n\t        // Create a data url for a canvas pin with custom label and color\n\t        this.canvasIcon = function (label, color, width, height) {\n\t            var canvas = document.createElement('canvas');\n\t            var context = canvas.getContext('2d');\n\n\t            width = width || lpPlacesUtils.markerWidth;\n\t            height = height || lpPlacesUtils.markerHeight;\n\n\t            canvas.width = width;\n\t            canvas.height = height;\n\n\t            context.clearRect(0, 0, width, height);\n\n\t            context.fillStyle = color;\n\t            context.strokeStyle = color;\n\n\t            drawPin(context, width, height);\n\n\t            context.fillStyle = 'white';\n\t            context.strokeStyle = 'black';\n\n\t            // Render Label\n\t            var fontSize = 10 - label.length; // Decide font size based on label's length\n\t            context.font = 'normal ' + fontSize + 'pt ' + lpPlacesUtils.markerFontFamily;\n\t            context.textBaseline = 'top';\n\n\t            // Centre text\n\t            var textWidth = context.measureText(label);\n\t            context.fillText(label, Math.floor(width / 2 - textWidth.width / 2), 4);\n\n\t            return canvas.toDataURL();\n\t        };\n\t    };\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {\n\t    'use strict';\n\n\t    var $ = __webpack_require__(11);\n\n\t    // @ngInject\n\t    exports.placesAutocomplete = function (lpPlacesUtils, lpCoreUtils) {\n\n\t        function linkFn(scope, element, attrs, ngModelCtrl) {\n\t            var autocomplete = new lpPlacesUtils.maps.places.Autocomplete(element[0]);\n\n\t            lpPlacesUtils.maps.event.addListener(autocomplete, 'place_changed', function () {\n\t                var place = autocomplete.getPlace(),\n\t                    isValid = !!place.geometry;\n\n\t                var args = {\n\t                    place: place\n\t                };\n\n\t                if (isValid) {\n\t                    args.location = place.geometry.location;\n\t                }\n\n\t                scope.$apply(function () {\n\t                    ngModelCtrl.$setValidity('place', isValid);\n\t                    ngModelCtrl.$setViewValue(element.val());\n\t                    scope.onPlaceChange({ result: args });\n\t                });\n\t            });\n\n\t            // Prevent IE from closing widget on enter\n\t            element.bind('keydown', function (e) {\n\t                if (e.keyCode === 13) {\n\t                    e.preventDefault();\n\t                }\n\t            });\n\t        }\n\n\t        return {\n\t            restrict: 'A',\n\t            require: 'ngModel',\n\t            scope: {\n\t                onPlaceChange: '&placesAutocomplete'\n\t            },\n\t            replace: false,\n\t            link: linkFn,\n\t            compile: function compile() {\n\t                /**\n\t                 * Fix to make the google maps autocomplete work in the webview using FastClick\n\t                 * http://stackoverflow.com/questions/21158507/google-places-autocomplete-issue-on-ios7-webview\n\t                 */\n\t                $(document).on({\n\t                    'DOMNodeInserted': function DOMNodeInserted() {\n\t                        $('.pac-item, .pac-item span', this).addClass('needsclick');\n\t                    }\n\t                }, '.pac-container');\n\n\t                return linkFn;\n\t            }\n\t        };\n\t    };\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_11__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** scripts/main.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d29fef576d576c86812f\n **/","define(function (require, exports, module) {\n    'use strict';\n\n    module.name = 'module-places';\n\n    var core = require('core');\n    var base = require('base');\n    var ui = require('ui');\n    require('./libs/angular-gm');\n\n    // requirejs async plugin\n    // Is ignored by webpack\n    require('async!//maps.google.com/maps/api/js?libraries=places');\n\n    var deps = [\n        core.name,\n        ui.name,\n        'AngularGM'\n    ];\n\n    module.exports = base.createModule(module.name, deps)\n        .constant( require('./utils') )\n        .service( require('./services') )\n        .directive( require('./places-autocomplete') );\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./scripts/main.js\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"core\"\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"base\"\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"ui\"\n ** module id = 5\n ** module chunks = 0\n **/","/*eslint-disable */\n/**\n * AngularGM - Google Maps Directives for AngularJS\n * @version v1.0.2 - 2015-06-17\n * @link http://dylanfprice.github.com/angular-gm\n * @author Dylan Price <the.dylan.price@gmail.com>\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n/**\n * @doc module\n * @name angulargm\n *\n * @description\n * Module for embedding Google Maps into AngularJS applications.\n *\n * # Example Plunkers ([fullscreen](http://embed.plnkr.co/PYDYjVuRHaJpdntoJtqL))\n *\n * <iframe style=\"width: 100%; height: 400px\" src=\"http://embed.plnkr.co/PYDYjVuRHaJpdntoJtqL\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\">\n * </iframe>\n *\n * Author: Dylan Price <the.dylan.price@gmail.com>\n */\n(function() {\n'use strict';\n\n  angular.module('AngularGM', []).\n\n  /**\n   * @ngdoc service\n   * @name angulargm.service:angulargmDefaults\n   *\n   * @description\n   * Default configuration.\n   *\n   * To provide your own default config, use the following\n   * ```js\n   * angular.module('myModule').config(function($provide) {\n   *   $provide.decorator('angulargmDefaults', function($delegate) {\n   *     return angular.extend($delegate, {\n   *       'precision': 3,\n   *       'markerConstructor': myCustomMarkerConstructor,\n   *       'polylineConstructor': myCustomPolylineConstructor,\n   *       'mapOptions': {\n   *         center: new google.maps.LatLng(55, 111),\n   *         mapTypeId: google.maps.MapTypeId.SATELLITE,\n   *         ...\n   *       }\n   *     });\n   *   });\n   * });\n   * ```\n   */\n  factory('angulargmDefaults', function() {\n    return {\n      'precision': 3,\n      'markerConstructor': google.maps.Marker,\n      'polylineConstructor': google.maps.Polyline,\n      'circleConstructor': google.maps.Circle,\n      'mapOptions': {\n        zoom : 8,\n        center : new google.maps.LatLng(46, -120),\n        mapTypeId : google.maps.MapTypeId.ROADMAP\n      }\n    };\n  });\n\n})();\n\n(function () {\n    'use strict';\n\n    angular.module('AngularGM').\n\n  directive('gmCircles', ['$parse', '$compile', '$timeout', '$log', 'angulargmUtils', 'angulargmShape',\n    function ($parse, $compile, $timeout, $log, angulargmUtils, angulargmShape) {\n\n        var objToLatLng = angulargmUtils.objToLatLng;\n\n        function link(scope, element, attrs, controller) {\n            if (!('gmCircleCenter' in attrs)) {\n                throw 'gmCircleCenter attribute required';\n            }\n\n            var circleOptions = function (object) {\n                var latLngObj = scope.gmCircleCenter({ object: object });\n                var center = objToLatLng(latLngObj);\n                if (center == null) {\n                    return null;\n                }\n                var circleOptions = scope.gmCircleOptions({ object: object });\n                var options = {};\n                angular.extend(options, circleOptions, { center: center });\n                return options;\n            };\n\n            angulargmShape.createShapeDirective(\n                'circle', scope, attrs, controller, circleOptions\n            );\n        }\n\n        return {\n            restrict: 'AE',\n            priority: 100,\n            scope: {\n                gmObjects: '&',\n                gmId: '&',\n                gmCircleCenter: '&',\n                gmCircleOptions: '&'\n            },\n            require: '^gmMap',\n            link: link\n        };\n    }]);\n})();\n/**\n * @ngdoc directive\n * @name angulargm.directive:gmInfoWindow\n * @element ANY\n *\n * @description\n * A directive for creating a google.maps.InfoWindow.\n *\n * @param {expression} gm-info-window scope variable to store the\n * [google.maps.InfoWindow](https://developers.google.com/maps/documentation/javascript/reference#InfoWindow)\n * in. Does not have to already exist.\n *\n * @param {expression} gm-info-window-options object in the current scope\n * that is a\n * [google.maps.InfoWindowOptions](https://developers.google.com/maps/documentation/javascript/reference#InfoWindowOptions)\n * object. If unspecified, google maps api defaults will be used.\n *\n * @param {expression} gm-on-*event* an angular expression which evaluates to an\n * event handler. This handler will be attached to the InfoWindow's \\*event\\*\n * event.  The variable `infoWindow` evaluates to the InfoWindow.  For example:\n * ```html\n * gm-on-closeclick=\"myCloseclickFn(infoWindow)\"\n * ```\n * will call your myCloseclickFn whenever the InfoWindow is clicked closed. You\n * may have multiple `gm-on-*event*` handlers, but only one for each type of\n * event.\n */\n(function () {\n'use strict';\n\n  angular.module('AngularGM').\n\n  /*\n   * Much of this code is taken from the Angular UI team, see:\n   * https://github.com/angular-ui/ui-map/blob/master/ui-map.js\n   */\n  directive('gmInfoWindow',\n    ['$parse', '$compile', '$timeout', 'angulargmUtils',\n    function ($parse, $compile, $timeout, angulargmUtils) {\n\n    /** aliases */\n    var getEventHandlers = angulargmUtils.getEventHandlers;\n\n    function link(scope, element, attrs, controller) {\n      var opts = angular.extend({}, scope.$eval(attrs.gmInfoWindowOptions));\n      opts.content = element[0];\n      var model = $parse(attrs.gmInfoWindow);\n      var infoWindow = model(scope);\n\n      if (!infoWindow) {\n        infoWindow = new google.maps.InfoWindow(opts);\n        model.assign(scope, infoWindow);\n      }\n\n      var handlers = getEventHandlers(attrs);\n\n      // set up info window event handlers\n      angular.forEach(handlers, function(handler, event) {\n        google.maps.event.addListener(infoWindow, event, function() {\n          $timeout(function() {\n            handler(scope, {\n              infoWindow: infoWindow\n            });\n          });\n        });\n      });\n    }\n\n    return {\n      restrict: 'A',\n      priority: 100,\n      scope: false,\n      link: link\n    };\n\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name angulargm.directive:gmMap\n * @element ANY\n *\n * @description\n * A directive for embedding google maps into your app.\n *\n * `gm-map-id` is required. The `gm-center`, `gm-zoom`, `gm-bounds`, and\n * `gm-map-type-id` variables do not have to exist in the current scope--they\n * will be created if necessary. All three have bi-directional association,\n * i.e.  drag or zoom the map and they will update, update them and the map\n * will change.  However, any initial state of these three variables will be\n * ignored.\n *\n * If you need to get a handle on the google.maps.Map object, see\n * {@link angulargm.service:angulargmContainer angulargmContainer}\n *\n * @param {expression} gm-map-id angular expression that evaluates to a unique\n * string id for the map, e.g. `'map_canvas'` or `myMapId` where myMapId is a\n * variable in the current scope. This allows you to have multiple\n * maps/instances of the directive.\n *\n *\n * @param {expression} gm-center center variable in the current scope.  The\n * value will be a google.maps.LatLng object.\n *\n *\n * @param {expression} gm-zoom zoom variable in the current scope.  Value will\n * be an integer.\n *\n *\n * @param {expression} gm-bounds bounds variable in the current scope.  Value\n * will be a google.maps.LatLngBounds object.\n *\n *\n * @param {expression} gm-map-type-id mapTypeId variable in the current scope.\n * Value will be a string.\n *\n *\n * @param {expression} gm-map-options object in the current scope that is a\n * google.maps.MapOptions object. If unspecified, will use the values in\n * angulargmDefaults.mapOptions. {@link angulargm.service:angulargmDefaults angulargmDefaults} is a service, so it is\n * both injectable and overrideable (using $provide.decorator).\n *\n * @param {expression} gm-on-*event* an angular expression which evaluates to\n * an event handler. This handler will be attached to each marker's \\*event\\*\n * event.  The variables 'map' and 'event' evaluate to the map and the\n * [google.maps.MouseEvent](https://developers.google.com/maps/documentation/javascript/reference#MouseEvent),\n * respectively. The map is always passed in, but the MouseEvent is only passed in if the event emits it.  For example:\n * ```html\n * gm-on-click=\"myClickFn(map, event)\"\n * ```\n * will call your `myClickFn` whenever the map is clicked.  You may have\n * multiple `gm-on-*event*` handlers, but only one for each type of event.  For events that have an underscore in their\n * name, such as 'center_changed', write it as 'gm-on-center-changed'.\n *\n *\n */\n\n/**\n * @ngdoc event\n * @name angulargm.directive:gmMap#gmMapResize\n * @eventOf angulargm.directive:gmMap\n * @eventType listen on current gmMap scope\n *\n * @description Alias for google.maps.event.trigger(map, 'resize')\n *\n * @param {string} mapId Required. The id of your map.\n * @example\n * ```js\n * $scope.$broadcast('gmMapResize', 'myMapId')\n * ```\n */\n\n/**\n * @ngdoc event\n * @name angulargm.directive:gmMap#gmMapIdle\n * @eventOf angulargm.directive:gmMap\n * @eventType emit on current gmMap scope\n *\n * @description Emitted when the map is finished loading (when the map fires\n * the 'idle' event).\n *\n * @param {string} mapId the id of the map which finished loading.\n *\n * @example\n * ```js\n * $scope.$on('gmMapIdle', function(event, mapId) {\n *     if (mapId === 'myMapId') {\n *       ...\n *     }\n * });\n * ```\n */\n\n(function () {\n'use strict';\n\n  angular.module('AngularGM').\n\n\n  directive('gmMap', ['$timeout', 'angulargmUtils', 'debounce', function ($timeout, angulargmUtils, debounce) {\n\n    /** aliases **/\n    var getEventHandlers = angulargmUtils.getEventHandlers;\n\n    /** link function **/\n    function link(scope, element, attrs, controller) {\n      // initialize scope\n      if (!angular.isDefined(scope.gmCenter)) {\n        scope.center = {};\n      }\n      if (!angular.isDefined(scope.gmBounds)) {\n        scope.bounds = {};\n      }\n\n      // Make sure gmMapId is defined\n      // Note: redundant check in MapController. Can't hurt.\n      if (!angular.isDefined(scope.gmMapId)) {\n        throw 'angulargm must have non-empty gmMapId attribute';\n      }\n\n      // Check what's defined in attrs\n      // Note: this is also redundant since angular will throw an exception if\n      // these attributes are not set. I may make these optional in the future\n      // (pending angular support).\n      var hasCenter = false;\n      var hasZoom = false;\n      var hasBounds = false;\n      var hasMapTypeId = false;\n\n      if (attrs.hasOwnProperty('gmCenter')) {\n        hasCenter = true;\n      }\n      if (attrs.hasOwnProperty('gmZoom')) {\n        hasZoom = true;\n      }\n      if (attrs.hasOwnProperty('gmBounds')) {\n        hasBounds = true;\n      }\n      if (attrs.hasOwnProperty('gmMapTypeId')) {\n        hasMapTypeId = true;\n      }\n\n      var _updateScope = function() {\n        $timeout(function () {\n          if (hasCenter || hasZoom || hasBounds || hasMapTypeId) {\n            scope.$apply(function (s) {\n              if (hasCenter) {\n                scope.gmCenter = controller.center;\n              }\n              if (hasZoom) {\n                scope.gmZoom = controller.zoom;\n              }\n              if (hasBounds) {\n                var b = controller.bounds;\n                if (b) {\n                  scope.gmBounds = b;\n                }\n              }\n              if (hasMapTypeId) {\n                scope.gmMapTypeId = controller.mapTypeId;\n              }\n            });\n          }\n        });\n      };\n\n      var updateScope = debounce(_updateScope, 100);\n\n      // Add event listeners to the map\n      controller.addMapListener('drag', updateScope);\n      controller.addMapListener('zoom_changed', updateScope);\n      controller.addMapListener('center_changed', updateScope);\n      controller.addMapListener('bounds_changed', updateScope);\n      controller.addMapListener('maptypeid_changed', updateScope);\n      controller.addMapListener('resize', updateScope);\n\n      // Add user supplied callbacks\n      var map = controller.getMap(attrs.gmMapId);\n      var handlers = getEventHandlers(attrs); // map events -> handlers\n      angular.forEach(handlers, function(handler, event) {\n        controller.addMapListener(event, function(ev) {\n          // pass the map in\n          var locals = {\n            map: map\n          };\n          // And optionally a MouseEvent object if it exists\n          if (ev !== undefined) {\n            locals.event = ev;\n          }\n\n          $timeout(function() {\n            handler(scope.$parent, locals);\n          });\n        });\n      });\n\n\n\n      if (hasCenter) {\n        scope.$watchCollection('gmCenter', function (newValue, oldValue) {\n          var changed = (newValue !== oldValue);\n          if (changed && !controller.dragging) {\n            var latLng = newValue;\n            if (latLng)\n              controller.center = latLng;\n          }\n        });\n      }\n\n      if (hasZoom) {\n        scope.$watch('gmZoom', function (newValue, oldValue) {\n          var ok = (newValue != null && !isNaN(newValue));\n          if (ok && newValue !== oldValue) {\n            controller.zoom = newValue;\n          }\n        });\n      }\n\n      if (hasBounds) {\n        scope.$watch('gmBounds', function(newValue, oldValue) {\n          var changed = (newValue !== oldValue);\n          if (changed && !controller.dragging) {\n            var bounds = newValue;\n            if (bounds)\n              controller.bounds = bounds;\n          }\n        });\n      }\n\n      if (hasMapTypeId) {\n        scope.$watch('gmMapTypeId', function(newValue, oldValue) {\n          var changed = (newValue !== oldValue);\n          if (changed && newValue) {\n            controller.mapTypeId = newValue;\n          }\n        });\n      }\n\n      scope.$on('gmMapResize', function(event, gmMapId) {\n        if (scope.gmMapId() === gmMapId) {\n          controller.mapTrigger('resize');\n        }\n      });\n\n      controller.addMapListenerOnce('idle', function() {\n        scope.$emit('gmMapIdle', scope.gmMapId());\n      });\n      controller.mapTrigger('resize');\n    }\n\n\n    return {\n      restrict: 'AE',\n      priority: 100,\n      template: '<div>' +\n                  '<div id=\"\" style=\"width:100%;height:100%;\"></div>' +\n                  '<div ng-transclude></div>' +\n                '</div>',\n      transclude: true,\n      replace: true,\n      scope: {\n        gmCenter: '=',\n        gmZoom: '=',\n        gmBounds: '=',\n        gmMapTypeId: '=',\n        gmMapOptions: '&',\n        gmMapId: '&'\n      },\n      controller: 'angulargmMapController',\n      link: link\n    };\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name angulargm.directive:gmMarkers\n * @element ANY\n *\n * @description\n * A directive for adding markers to a `gmMap`. You may have multiple per `gmMap`.\n *\n * To use, you specify an array of custom objects and tell the directive how to\n * extract an id and position from them. A marker will be created for each of\n * your objects. If you assign a new array to your scope variable or change the\n * array's length (i.e. add or remove an object), the markers will also update.\n * The one case where `gmMarkers` can not automatically detect changes to your\n * objects is when you mutate objects in the array. To inform the directive of\n * such changes, see the `gmMarkersUpdate` event below.\n *\n * Only the `gm-objects`, `gm-id` and `gm-position` attributes are required.\n *\n * @param {expression} gm-objects an array of objects in the current scope.\n * These can be any objects you wish to attach to markers, the only requirement\n * is that they have a uniform method of accessing an id and a position.\n *\n * @param {expression} gm-id an angular expression that given an object from\n * `gm-objects`, evaluates to a unique identifier for that object. Your object\n * can be accessed through the variable `object`. See `gm-position` below for\n * an example.\n *\n * @param {expression} gm-position an angular expression that given an object from\n * `gm-objects`, evaluates to an object with lat and lng properties. Your\n * object can be accessed through the variable `object`.  For example, if\n * your controller has\n * ```js\n * ...\n * $scope.myObjects = [\n *   { id: 0, location: { lat: 5, lng: 5} },\n *   { id: 1, location: { lat: 6, lng: 6} }\n * ]\n * ...\n * ```\n * then in the `gm-markers` directive you would put\n * ```js\n * ...\n * gm-objects=\"myObjects\"\n * gm-id=\"object.id\"\n * gm-position=\"{ lat: object.location.lat, lng: object.location.lng }\"\n * ...\n * ```\n *\n *\n * @param {expression} gm-marker-options an angular expression that given\n * an object from `gm-objects`, evaluates to a\n * [google.maps.MarkerOptions](https://developers.google.com/maps/documentation/javascript/reference#MarkerOptions)\n * object.  Your object can be accessed through the variable `object`. If\n * unspecified, google maps api defaults will be used.\n *\n *\n * @param {expression} gm-events a variable in the current scope that is used to\n * simulate events on markers. Setting this variable to an object of the form\n * ```js\n *     [\n *       {\n *         event: 'click',\n *         ids: [id1, ...]\n *       },\n *       ...\n *     ]\n * ```\n * will generate the named events on the markers with the given ids, if a\n * marker with each id exists. Note: when setting the `gm-events` variable, you\n * must set it to a new object for the changes to be detected.  Code like\n * ```js\n * myEvents[0][\"ids\"] = [0]\n * ```\n * will not work.\n *\n *\n * @param {expression} gm-on-*event* an angular expression which evaluates to\n * an event handler. This handler will be attached to each marker's \\*event\\*\n * event.  The variables 'object' and 'marker' evaluate to your object and the\n * [google.maps.Marker](https://developers.google.com/maps/documentation/javascript/reference#Marker),\n * respectively. For example:\n * ```html\n * gm-on-click=\"myClickFn(object, marker)\"\n * ```\n * will call your `myClickFn` whenever a marker is clicked.  You may have\n * multiple `gm-on-*event*` handlers, but only one for each type of event.\n * For events that have an underscore in their name, such as\n * 'position_changed', write it as 'gm-on-position-changed'.\n */\n\n/**\n * @ngdoc event\n * @name angulargm.directive:gmMarkers#gmMarkersUpdate\n * @eventOf angulargm.directive:gmMarkers\n * @eventType listen on current gmMarkers scope\n *\n * @description Manually tell the `gmMarkers` directive to update the markers.\n * This is useful to tell the directive when an object from `gm-objects` is\n * mutated--`gmMarkers` can not pick up on such changes automatically.\n *\n * @param {string} objects Not required. The name of the scope variable which\n * holds the objects to update markers for, i.e. what you set `gm-objects` to.\n * It is useful because there may be multiple instances of the `gmMarkers`\n * directive. If not specified, all instances of `gmMarkers` which are child\n * scopes will update their markers.\n *\n * @example\n * ```js\n * $scope.$broadcast('gmMarkersUpdate', 'myObjects');\n * ```\n */\n\n/**\n * @ngdoc event\n * @name angulargm.directive:gmMarkers#gmMarkersRedraw\n * @eventOf angulargm.directive:gmMarkers\n * @eventType listen on current gmMarkers scope\n *\n * @description Force the `gmMarkers` directive to clear and redraw all markers.\n *\n * @param {string} objects Not required. The name of the scope variable which\n * holds the objects to redraw markers for, i.e. what you set `gm-objects` to.\n * It is useful because there may be multiple instances of the `gmMarkers`\n * directive. If not specified, all instances of `gmMarkers` which are child\n * scopes will redraw their markers.\n *\n * @example\n * ```js\n * $scope.$broadcast('gmMarkersRedraw', 'myObjects');\n * ```\n */\n\n/**\n * @ngdoc event\n * @name angulargm.directive:gmMarkers#gmMarkersUpdated\n * @eventOf angulargm.directive:gmMarkers\n * @eventType emit on current gmMarkers scope\n *\n * @description Emitted when markers are updated.\n *\n * @param {string} objects the name of the scope variable which holds the\n * objects the `gmMarkers` directive was constructed with. This is what\n * `gm-objects` was set to.\n *\n * @example\n * ```js\n * $scope.$on('gmMarkersUpdated', function(event, objects) {\n *     if (objects === 'myObjects') {\n *       ...\n *     }\n * });\n * ```\n */\n\n(function () {\n'use strict';\n\n  angular.module('AngularGM').\n\n  directive('gmMarkers',\n    ['$log', '$parse', '$timeout', 'angulargmUtils', 'angulargmShape',\n    function($log, $parse, $timeout, angulargmUtils, angulargmShape) {\n\n    /** aliases */\n    var objToLatLng = angulargmUtils.objToLatLng;\n\n    function link(scope, element, attrs, controller) {\n      // check marker attrs\n      if (!('gmPosition' in attrs)) {\n        throw 'gmPosition attribute required';\n      }\n\n      var markerOptions = function(object) {\n        var latLngObj = scope.gmPosition({object: object});\n        var position = objToLatLng(latLngObj);\n        if (position == null) {\n          return null;\n        }\n\n        var markerOptions = scope.gmMarkerOptions({object: object});\n        var options = {};\n        angular.extend(options, markerOptions, {position: position});\n        return options;\n      };\n\n      angulargmShape.createShapeDirective(\n        'marker', scope, attrs, controller, markerOptions\n      );\n    }\n\n    return {\n      restrict: 'AE',\n      priority: 100,\n      scope: {\n        gmObjects: '&',\n        gmId: '&',\n        gmPosition: '&',\n        gmMarkerOptions: '&',\n        gmEvents: '&'\n      },\n      require: '^gmMap',\n      link: link\n    };\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name angulargm.directive:gmPolylines\n * @element ANY\n *\n * @description\n * A directive for adding polylines to a `gmMap`. You may have multiple per `gmMap`.\n *\n * To use, you specify an array of custom objects and tell the directive how to\n * extract location data from them. A polyline will be created for each of your\n * objects. If you assign a new array to your scope variable or change the\n * array's length, the polylines will also update.  The one case where\n * `gmPolylines` can not automatically detect changes to your objects is when\n * you mutate objects in the array. To inform the directive of such changes,\n * see the `gmPolylinesUpdate` event below.\n *\n * Only the `gm-objects`, `gm-id` and `gm-path` attributes are required.\n *\n * @param {expression} gm-objects an array of objects in the current scope.\n * These can be any objects you wish to attach to polylines, the only requirement\n * is that they have a uniform method of accessing an id and a path.\n *\n * @param {expression} gm-path an angular expression that given an object\n * from `gm-objects`, evaluates to an array of objects with lat and lng\n * properties. Your object can be accessed through the variable `object`.  For\n * example, if your controller has\n * ```js\n * ...\n * $scope.myObjects = [\n *   { id: 0, path: [ { lat: 5, lng: 5}, {lat: 4, lng: 4} ]},\n *   { id: 1, path: [ { lat: 6, lng: 6}, {lat: 7, lng: 7} ]}\n * ]\n * ...\n * ```\n * then in the `gm-polylines` directive you would put\n * ```js\n * ...\n * gm-objects=\"myObjects\"\n * gm-get-path=\"object.path\"\n * ...\n * ```\n *\n * @param {expression} gm-polyline-options an angular expression that given\n * an object from `gm-objects`, evaluates to a\n * [google.maps.PolylineOptions](https://developers.google.com/maps/documentation/javascript/reference#PolylineOptions)\n * object.  Your object can be accessed through the variable `object`. If\n * unspecified, google maps api defaults will be used.\n *\n * @param {expression} gm-events a variable in the current scope that is used to\n * simulate events on polylines. Setting this variable to an object of the form\n * ```js\n *     [\n *       {\n *         event: 'click',\n *         ids: [id1, ...]\n *       },\n *       ...\n *     ]\n * ```\n * will generate the named events on the polylines with the given ids, if a\n * polyline with each id exists. Note: when setting the `gm-events` variable, you\n * must set it to a new object for the changes to be detected.  Code like\n * ```js\n * myEvents[0][\"ids\"] = [0]\n * ```\n * will not work.\n *\n *\n * @param {expression} gm-on-*event* an angular expression which evaluates to\n * an event handler. This handler will be attached to each polyline's \\*event\\*\n * event.  The variables 'object' and 'polyline' evaluate to your object and the\n * [google.maps.Polyline](https://developers.google.com/maps/documentation/javascript/reference#Polyline),\n * respectively. For example:\n * ```html\n * gm-on-click=\"myClickFn(object, polyline)\"\n * ```\n * will call your `myClickFn` whenever a polyline is clicked.  You may have\n * multiple `gm-on-*event*` handlers, but only one for each type of event.\n * For events that have an underscore in their name, such as\n * 'position_changed', write it as 'gm-on-position-changed'.\n */\n\n/**\n * @ngdoc event\n * @name angulargm.directive:gmPolylines#gmPolylinesUpdate\n * @eventOf angulargm.directive:gmPolylines\n * @eventType listen on current gmPolylines scope\n *\n * @description Manually tell the `gmPolylines` directive to update the polylines.\n * This is useful to tell the directive when an object from `gm-objects` is\n * mutated--`gmPolylines` can not pick up on such changes automatically.\n *\n * @param {string} objects Not required. The name of the scope variable which\n * holds the objects to update polylines for, i.e. what you set `gm-objects` to.\n * It is useful because there may be multiple instances of the `gmPolylines`\n * directive. If not specified, all instances of `gmPolylines` which are child\n * scopes will update their polylines.\n *\n * @example\n * ```js\n * $scope.$broadcast('gmPolylinesUpdate', 'myObjects');\n * ```\n */\n\n/**\n * @ngdoc event\n * @name angulargm.directive:gmPolylines#gmPolylinesRedraw\n * @eventOf angulargm.directive:gmPolylines\n * @eventType listen on current gmPolylines scope\n *\n * @description Force the gmPolylines directive to clear and redraw all polylines.\n *\n * @param {string} objects Not required. The name of the scope variable which\n * holds the objects to redraw polylines for, i.e. what you set `gm-objects` to.\n * It is useful because there may be multiple instances of the `gmPolylines`\n * directive. If not specified, all instances of gmPolylines which are child\n * scopes will redraw their polylines.\n *\n * @example\n * ```js\n * $scope.$broadcast('gmPolylinesRedraw', 'myObjects');\n * ```\n */\n\n/**\n * @ngdoc event\n * @name angulargm.directive:gmPolylines#gmPolylinesUpdated\n * @eventOf angulargm.directive:gmPolylines\n * @eventType emit on current gmPolylines scope\n *\n * @description Emitted when polylines are updated.\n *\n * @param {string} objects the name of the scope variable which holds the\n * objects the gmPolylines directive was constructed with. This is what\n * `gm-objects` was set to.\n *\n * @example\n * ```js\n * $scope.$on('gmPolylinesUpdated', function(event, objects) {\n *     if (objects === 'myObjects') {\n *       ...\n *     }\n * });\n * ```\n */\n\n(function () {\n'use strict';\n\n  angular.module('AngularGM').\n\n  directive('gmPolylines', ['$parse', '$compile', '$timeout', '$log', 'angulargmUtils', 'angulargmShape',\n    function ($parse, $compile, $timeout, $log, angulargmUtils, angulargmShape) {\n    /** aliases */\n    var objToLatLng = angulargmUtils.objToLatLng;\n\n    function link(scope, element, attrs, controller) {\n      if (!('gmPath' in attrs)) {\n        throw 'gmPath attribute required';\n      }\n\n      var polylineOptions = function(object) {\n        var lineLatLngs = scope.gmPath({object: object});\n        var path = [];\n\n        angular.forEach(lineLatLngs, function(latlng) {\n          var position = objToLatLng(latlng);\n          if (position == null) {\n              $log.warn('Unable to generate lat/lng from ', latlng);\n              return;\n          }\n          path.push(position);\n        });\n\n        var polylineOptions = scope.gmPolylineOptions({object: object});\n        var options = {};\n        angular.extend(options, polylineOptions, {path: path});\n        return options;\n      };\n\n      angulargmShape.createShapeDirective(\n        'polyline', scope, attrs, controller, polylineOptions\n      );\n    }\n\n    return {\n      restrict: 'AE',\n      priority: 100,\n      scope: {\n        gmObjects: '&',\n        gmId: '&',\n        gmPath: '&',\n        gmPolylineOptions: '&',\n        gmEvents: '&'\n      },\n      require: '^gmMap',\n      link: link\n    };\n  }]);\n})();\n\n/**\n * @ngdoc service\n * @name angulargm.service:angulargmContainer\n *\n * @description\n * A container which maps mapIds to google.maps.Map instances, and additionally\n * allows getting a promise of a map for custom configuration of the map.\n *\n * If you want a handle to the map, you should use the `getMapPromise(mapId)`\n * method so you can guarantee the map will be initialized. For example,\n *\n * ```js\n * angular.module('myModule').\n *\n * run(function(angulargmContainer) {\n *   var gmapPromise = angulargmContainer.getMapPromise('myMapid');\n *\n *   gmapPromise.then(function(gmap) {\n *     // google map configuration here\n *   });\n * });\n * ```\n */\n(function () {\n'use strict';\n\n  angular.module('AngularGM').\n\n  factory('angulargmContainer', ['$q', function($q) {\n    var maps = {};\n    var defers = {};\n\n    /**\n     * Add a map to the container.\n     * @param {string} mapId the unique identifier for the map\n     * @param {google.maps.Map} map the google map\n     * @throw if there is already a map with mapId, or if map is not a\n     *   google.maps.Map\n     */\n    function addMap(mapId, map) {\n      if (!(map instanceof google.maps.Map)) {\n        throw 'map not a google.maps.Map: ' + map;\n      } else if (mapId in maps) {\n        throw 'already contain map with id ' + mapId;\n      }\n      maps[mapId] = map;\n      if (mapId in defers) {\n        defers[mapId].resolve(map);\n      }\n    }\n\n    /**\n     * Get a map from the container.\n     * @param {string} mapId the unique id of the map\n     * @return {google.maps.Map|undefined} the map, or undefined if there is no\n     *   map for mapId\n     */\n    function getMap(mapId) {\n      return maps[mapId];\n    }\n\n    /**\n     * Returns a promise of a map for the given mapId\n     * @param {string} mapId the unique id of the map that may or may not have\n     *   been created yet\n     * @return {angular.q.promise} a promise of a map that will be resolved\n     *   when the map is added\n     */\n    function getMapPromise(mapId) {\n      var defer = defers[mapId] || $q.defer();\n      var map = getMap(mapId);\n      defers[mapId] = defer;\n      if (map !== undefined) {\n        defer.resolve(map);\n      }\n      return defer.promise;\n    }\n\n    /**\n     * Removes map with given mapId from this container, and deletes the map.\n     * In order for this to work you must ensure there are no references to the\n     * map object. Note: this will likely cause a memory leak, see\n     * http://stackoverflow.com/questions/10485582/what-is-the-proper-way-to-destroy-a-map-instance\n     *\n     * @param {string} mapId the unique id of the map to remove\n     */\n    function removeMap(mapId) {\n      if (mapId in maps) {\n        delete maps[mapId];\n      }\n      if (mapId in defers) {\n        delete defers[mapId];\n      }\n    }\n\n    /**\n     * Removes all maps and unresolved map promises. Only for testing, see\n     * #removeMap(mapId).\n     */\n    function clear() {\n      maps = {};\n      defers = {};\n    }\n\n    return {\n      addMap: addMap,\n      getMap: getMap,\n      getMapPromise: getMapPromise,\n      removeMap: removeMap,\n      clear: clear\n    };\n  }]);\n})();\n\n/**\n * @ngdoc service\n * @name angulargm.service:angulargmShape\n *\n * @description\n * Directive functions for map shapes (marker, polyline, etc.)\n */\n(function () {\n'use strict';\n\n  angular.module('AngularGM').\n\n  factory('angulargmShape',\n    ['$timeout', 'angulargmUtils',\n    function($timeout, angulargmUtils) {\n\n    /**\n     * Check required attributes of a shape.\n     */\n    function checkRequiredAttributes(attrs) {\n      if (!('gmObjects' in attrs)) {\n        throw 'gmObjects attribute required';\n      } else if (!('gmId' in attrs)) {\n        throw 'gmId attribute required';\n      }\n    }\n\n    /**\n     * Create a mapping from object id -> object.\n     * The object id is retrieved using scope.gmId\n     */\n    function _generateObjectCache(scope, objects) {\n      var objectCache = {};\n      angular.forEach(objects, function(object) {\n        // cache objects for quick access\n        var id = scope.gmId({object: object});\n        objectCache[id] = object;\n      });\n      return objectCache;\n    }\n\n    /**\n     * Create new shapes and add them to the map for objects which are not\n     * currently on the map.\n     */\n    function _addNewElements(type, scope, controller, handlers, objectCache, optionsFn) {\n      angular.forEach(objectCache, function(object, id) {\n        var element = controller.getElement(type, scope.$id, id);\n\n        var options = optionsFn(object);\n        if (options == null) {\n          return;\n        }\n\n        if (element) {\n          controller.updateElement(type, scope.$id, id, options);\n        } else {\n          controller.addElement(type, scope.$id, id, options);\n          element = controller.getElement(type, scope.$id, id);\n\n          // set up element event handlers\n          angular.forEach(handlers, function(handler, event) {\n            controller.addListener(element, event, function() {\n              $timeout(function() {\n                var context = {object: object};\n                context[type] = element;\n                if ((angular.version.major <= 1) && (angular.version.minor <= 2)) {\n                  // scope is this directive's isolate scope\n                  // scope.$parent is the scope of ng-transclude\n                  // scope.$parent.$parent is the one we want\n                  handler(scope.$parent.$parent, context);\n                } else {\n                  handler(scope.$parent.$parent.$parent , context);\n                }\n              });\n            });\n          });\n        }\n      });\n    }\n\n    /**\n     * Remove shape elements from the map which are no longer in objects.\n     */\n    function _removeOrphanedElements(type, scope, controller, objectCache) {\n      var orphaned = [];\n\n      controller.forEachElementInScope(type, scope.$id, function(element, id) {\n        if (!(id in objectCache)) {\n          orphaned.push(id);\n        }\n      });\n\n      angular.forEach(orphaned, function(id) {\n        controller.removeElement(type, scope.$id, id);\n      });\n    }\n\n    /**\n     * _formatEventName('gmShapesUpdated', 'marker') -> 'gmMarkersUpdated'\n     */\n    function _formatEventName(template, type) {\n      var uppercasePluralType = type.charAt(0).toUpperCase() + type.slice(1) + 's';\n      return template.replace('Shapes', uppercasePluralType);\n    }\n\n    /**\n     * Attach necessary watchers and listeners to scope to deal with:\n     * - updating objects\n     * - handling gmEvents\n     * - listening for events\n     */\n    function _attachEventListeners(type, scope, attrs, controller, updateElements) {\n\n      // watch objects\n      scope.$watch('gmObjects().length', function(newValue, oldValue) {\n        if (newValue != null && newValue !== oldValue) {\n          updateElements(scope, scope.gmObjects());\n        }\n      });\n\n      scope.$watch('gmObjects()', function(newValue, oldValue) {\n        if (newValue != null && newValue !== oldValue) {\n          updateElements(scope, scope.gmObjects());\n        }\n      });\n\n      // watch gmEvents\n      scope.$watch('gmEvents()', function(newValue, oldValue) {\n        if (newValue != null && newValue !== oldValue) {\n          angular.forEach(newValue, function(eventObj) {\n            var event = eventObj.event;\n            var ids = eventObj.ids;\n            angular.forEach(ids, function(id) {\n              var element = controller.getElement(type, scope.$id, id);\n              if (element != null) {\n                $timeout(angular.bind(this, controller.trigger, element, event));\n              }\n            });\n          });\n        }\n      });\n\n      scope.$on(_formatEventName('gmShapesRedraw', type), function(event, objectsName) {\n        if (objectsName == null || objectsName === attrs.gmObjects) {\n          updateElements(scope);\n          updateElements(scope, scope.gmObjects());\n        }\n      });\n\n      scope.$on(_formatEventName('gmShapesUpdate', type), function(event, objectsName) {\n        if (objectsName == null || objectsName === attrs.gmObjects) {\n          updateElements(scope, scope.gmObjects());\n        }\n      });\n    }\n\n    /**\n     * Takes care of setting up the directive for the given type of shape.\n     * Assumes the following directive scope:\n     *   scope: {\n     *     gmId: '&',\n     *     gmObjects: '&',\n     *     gmEvents: '&'\n     *   },\n     *\n     * And the angulargmMapController:\n     *   require: '^gmMap',\n     *\n     * Also supports the following attributes:\n     *   gmOn* (though some of this knowledge is in angulargmUtils as well)\n     *\n     * As well as the following events\n     *   gmShapesUpdated\n     *   gmShapesRedraw\n     *\n     * (e.g. gmMarkersUpdated and gmMarkersRedraw)\n     *\n     * See gmMarkers for a complete example.\n     */\n    function createShapeDirective(type, scope, attrs, controller, elementOptions) {\n      checkRequiredAttributes(attrs);\n\n      var updateElements = function(scope, objects) {\n        var objectCache = _generateObjectCache(scope, objects);\n        var handlers = angulargmUtils.getEventHandlers(attrs); // map events -> handlers\n\n        _addNewElements(\n          type, scope, controller, handlers,\n          objectCache, elementOptions\n        );\n\n        _removeOrphanedElements(type, scope, controller, objectCache);\n\n        scope.$emit(_formatEventName('gmShapesUpdated', type), attrs.gmObjects);\n      };\n\n      _attachEventListeners(type, scope, attrs, controller, updateElements);\n\n      // initialize elements\n      $timeout(angular.bind(null, updateElements, scope, scope.gmObjects()));\n    }\n\n    return {\n      createShapeDirective: createShapeDirective\n    };\n  }]);\n})();\n\n/**\n * @ngdoc service\n * @name angulargm.service:angulargmUtils\n *\n * @description\n * Common utility functions.\n */\n(function () {\n'use strict';\n\n  angular.module('AngularGM').\n\n  factory('angulargmUtils', ['$parse', function($parse) {\n\n    /**\n     * Check if two floating point numbers are equal.\n     *\n     * @param {number} f1 first number\n     * @param {number} f2 second number\n     * @return {boolean} true if f1 and f2 are 'very close' (within 0.000001)\n     */\n    function floatEqual (f1, f2) {\n      return (Math.abs(f1 - f2) < 0.000001);\n    }\n\n    /**\n     * @ngdoc function\n     * @name #latLngEqual\n     * @methodOf angulargm.service:angulargmUtils\n     *\n     * @param {google.maps.LatLng} l1 first\n     * @param {google.maps.LatLng} l2 second\n     * @return {boolean} true if l1 and l2 are 'very close'. If either are null\n     * or not google.maps.LatLng objects returns false.\n     */\n    function latLngEqual(l1, l2) {\n      if (!(l1 instanceof google.maps.LatLng &&\n            l2 instanceof google.maps.LatLng)) {\n        return false;\n      }\n      return floatEqual(l1.lat(), l2.lat()) && floatEqual(l1.lng(), l2.lng());\n    }\n\n    /**\n     * @ngdoc function\n     * @name #boundsEqual\n     * @methodOf angulargm.service:angulargmUtils\n     *\n     * @param {google.maps.LatLngBounds} b1 first\n     * @param {google.maps.LatLngBounds} b2 second\n     * @return {boolean} true if b1 and b2 are 'very close'. If either are null\n     * or not google.maps.LatLngBounds objects returns false.\n     */\n    function boundsEqual(b1, b2) {\n      if (!(b1 instanceof google.maps.LatLngBounds &&\n            b2 instanceof google.maps.LatLngBounds)) {\n        return false;\n      }\n      var sw1 = b1.getSouthWest();\n      var sw2 = b2.getSouthWest();\n      var ne1 = b1.getNorthEast();\n      var ne2 = b2.getNorthEast();\n\n      return latLngEqual(sw1, sw2) && latLngEqual(ne1, ne2);\n    }\n\n    /**\n     * @ngdoc function\n     * @name #latLngToObj\n     * @methodOf angulargm.service:angulargmUtils\n     *\n     * @param {google.maps.LatLng} latLng the LatLng\n     * @return {Object} object literal with 'lat' and 'lng' properties.\n     * @throw if latLng not instanceof google.maps.LatLng\n     */\n    function latLngToObj(latLng) {\n      if (!(latLng instanceof google.maps.LatLng))\n        throw 'latLng not a google.maps.LatLng';\n\n      return {\n        lat: latLng.lat(),\n        lng: latLng.lng()\n      };\n    }\n\n    /**\n     * @ngdoc function\n     * @name #objToLatLng\n     * @methodOf angulargm.service:angulargmUtils\n     *\n     * @param {Object} obj of the form { lat: 40, lng: -120 }\n     * @return {google.maps.LatLng} returns null if problems with obj (null,\n     * NaN, etc.)\n     */\n    function objToLatLng(obj) {\n      if (obj != null) {\n        var lat = obj.lat;\n        var lng = obj.lng;\n        var ok = !(lat == null || lng == null) && !(isNaN(lat) ||\n            isNaN(lng));\n        if (ok) {\n          return new google.maps.LatLng(lat, lng);\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @ngdoc function\n     * @name #hasNaN\n     * @methodOf angulargm.service:angulargmUtils\n     *\n     * @param {google.maps.LatLng} latLng the LatLng\n     * @return {boolean} true if either lat or lng of latLng is null or isNaN\n     */\n    function hasNaN(latLng) {\n      if (!(latLng instanceof google.maps.LatLng))\n        throw 'latLng must be a google.maps.LatLng';\n\n      // google.maps.LatLng converts NaN to null, so check for both\n      var isNull = (latLng.lat() == null || latLng.lng() == null);\n      var isNotaN =  isNaN(latLng.lat()) || isNaN(latLng.lng());\n      return isNull || isNotaN;\n    }\n\n    /**\n     * @param {Object} attrs directive attributes\n     * @return {Object} mapping from event names to handler fns\n     */\n    function getEventHandlers(attrs) {\n      var handlers = {};\n\n      // retrieve gm-on-___ handlers\n      angular.forEach(attrs, function(value, key) {\n        if (key.lastIndexOf('gmOn', 0) === 0) {\n          var event = angular.lowercase(\n            key.substring(4)\n              .replace(/(?!^)([A-Z])/g, '_$&')\n          );\n          var fn = $parse(value);\n          handlers[event] = fn;\n        }\n      });\n\n      return handlers;\n    }\n\n    function assertDefined(value, name) {\n      if (value === undefined || value === null) {\n        if (name) {\n          throw name + ' was: ' + value;\n        } else {\n          throw 'value was: ' + value;\n        }\n      }\n    }\n\n    return {\n      latLngEqual: latLngEqual,\n      boundsEqual: boundsEqual,\n      latLngToObj: latLngToObj,\n      objToLatLng: objToLatLng,\n      hasNaN: hasNaN,\n      getEventHandlers: getEventHandlers,\n      assertDefined: assertDefined\n    };\n  }]);\n})();\n\n/**\n * @ngdoc service\n * @name angulargm.service:debounce\n *\n * @description\n * Debounce function. Stolen from https://github.com/shahata/angular-debounce\n */\n(function () {\n'use strict';\n\n  angular.module('AngularGM').\n\n  factory('debounce', ['$timeout', function ($timeout) {\n    return function (func, wait, immediate) {\n      var timeout, args, context, result;\n      function debounce() {\n        /* jshint validthis:true */\n        context = this;\n        args = arguments;\n        var later = function () {\n          timeout = null;\n          if (!immediate) {\n            result = func.apply(context, args);\n          }\n        };\n        var callNow = immediate && !timeout;\n        if (timeout) {\n          $timeout.cancel(timeout);\n        }\n        timeout = $timeout(later, wait);\n        if (callNow) {\n          result = func.apply(context, args);\n        }\n        return result;\n      }\n      debounce.cancel = function () {\n        $timeout.cancel(timeout);\n        timeout = null;\n      };\n      return debounce;\n    };\n  }]);\n\n})();\n\n/**\n * Directive controller which is owned by the [gmMap]{@link module:gmMap}\n * directive and shared among all other angulargm directives.\n */\n(function () {\n'use strict';\n\n  angular.module('AngularGM').\n\n  controller('angulargmMapController',\n    ['$scope', '$element', 'angulargmUtils', 'angulargmDefaults',\n    'angulargmContainer',\n\n    function ($scope, $element, angulargmUtils, angulargmDefaults,\n      angulargmContainer) {\n\n    /** aliases */\n    var latLngEqual = angulargmUtils.latLngEqual;\n    var boundsEqual = angulargmUtils.boundsEqual;\n    var hasNaN = angulargmUtils.hasNaN;\n    var assertDefined = angulargmUtils.assertDefined;\n\n    /*\n     * Construct a new controller for the gmMap directive.\n     * @param {angular.Scope} $scope\n     * @param {angular.element} $element\n     * @constructor\n     */\n    var constructor = function($scope, $element) {\n\n      var mapId = $scope.gmMapId();\n      if (!mapId) { throw 'angulargm must have non-empty gmMapId attribute'; }\n\n      var mapDiv = angular.element($element[0].firstChild);\n      mapDiv.attr('id', mapId);\n\n      var config = this._getConfig($scope, angulargmDefaults);\n\n      // 'private' properties\n      this._map = this._createMap(mapId, mapDiv, config, angulargmContainer, $scope);\n      this._elements = {};\n      this._listeners = {};\n\n      // 'public' properties\n      this.dragging = false;\n\n      Object.defineProperties(this, {\n        'precision': {\n          value: angulargmDefaults.precision,\n          writeable: false\n        },\n\n        'center': {\n          configurable: true, // for testing so we can mock\n          get: function() {\n             return this._map.getCenter();\n           },\n          set: function(center) {\n            if (hasNaN(center))\n              throw 'center contains null or NaN';\n            var changed = !latLngEqual(this.center, center);\n            if (changed) {\n              this._map.panTo(center);\n            }\n          }\n        },\n\n        'zoom': {\n          configurable: true, // for testing so we can mock\n          get: function() {\n            return this._map.getZoom();\n          },\n          set: function(zoom) {\n            if (!(zoom != null && !isNaN(zoom)))\n              throw 'zoom was null or NaN';\n            var changed = this.zoom !== zoom;\n            if (changed) {\n              this._map.setZoom(zoom);\n            }\n          }\n        },\n\n        'bounds': {\n          configurable: true, // for testing so we can mock\n          get: function() {\n            return this._map.getBounds();\n          },\n          set: function(bounds) {\n            var numbers = !hasNaN(bounds.getSouthWest()) &&\n                          !hasNaN(bounds.getNorthEast());\n            if (!numbers)\n              throw 'bounds contains null or NaN';\n\n            var changed = !(boundsEqual(this.bounds, bounds));\n            if (changed) {\n              this._map.fitBounds(bounds);\n            }\n          }\n        },\n\n        'mapTypeId': {\n          configurable: true, // for testing so we can mock\n          get: function() {\n            return this._map.getMapTypeId();\n          },\n          set: function(mapTypeId) {\n            if (mapTypeId == null)\n              throw 'mapTypeId was null or unknown';\n            var changed = this.mapTypeId !== mapTypeId;\n            if (changed) {\n              this._map.setMapTypeId(mapTypeId);\n            }\n          }\n        }\n      });\n\n      this._initDragListeners();\n      $scope.$on('$destroy', angular.bind(this, this._destroy));\n    };\n\n\n    // Retrieve google.maps.MapOptions\n    this._getConfig = function($scope, angulargmDefaults) {\n      // Get config or defaults\n      var defaults = angulargmDefaults.mapOptions;\n      var config = {};\n      angular.extend(config, defaults, $scope.gmMapOptions());\n      return config;\n    };\n\n\n    // Create the map and add to angulargmContainer\n    this._createMap = function(id, element, config, angulargmContainer) {\n      var map = angulargmContainer.getMap(id);\n      if (!map) {\n        map = new google.maps.Map(element[0], config);\n        angulargmContainer.addMap(id, map);\n      } else {\n        var div = map.getDiv();\n        element.replaceWith(div);\n        this._map = map;\n        this.mapTrigger('resize');\n        map.setOptions(config);\n      }\n      return map;\n    };\n\n\n    // Set up listeners to update this.dragging\n    this._initDragListeners = function() {\n      var self = this;\n      this.addMapListener('dragstart', function () {\n        self.dragging = true;\n      });\n\n      this.addMapListener('idle', function () {\n        self.dragging = false;\n      });\n    };\n\n\n    this._destroy = function() {\n      angular.forEach(this._listeners, function(listener) {\n        angular.forEach(listener, function(l) {\n          google.maps.event.removeListener(l);\n        });\n      });\n      this._listeners = {};\n\n      var self = this;\n      var types = Object.keys(this._elements);\n      angular.forEach(types, function(type) {\n        var scopeIds = Object.keys(self._getElements(type));\n        angular.forEach(scopeIds, function(scopeId) {\n          self.forEachElementInScope(type, scopeId, function(element, id) {\n            self.removeElement(type, scopeId, id);\n          });\n        });\n      });\n\n      var streetView = this._map.getStreetView();\n      if (streetView && streetView.getVisible()) {\n        streetView.setVisible(false);\n      }\n    };\n\n\n    /**\n     * Alias for google.maps.event.addListener(map, event, handler)\n     * @param {string} event an event defined on google.maps.Map\n     * @param {Function} a handler for the event\n     */\n    this.addMapListener = function(event, handler) {\n      var listener = google.maps.event.addListener(this._map, event, handler);\n\n      if (this._listeners[event] === undefined) {\n        this._listeners[event] = [];\n      }\n\n      this._listeners[event].push(listener);\n    };\n\n\n    /**\n     * Alias for google.maps.event.addListenerOnce(map, event, handler)\n     * @param {string} event an event defined on google.maps.Map\n     * @param {Function} a handler for the event\n     */\n    this.addMapListenerOnce = function(event, handler) {\n      var listener = google.maps.event.addListenerOnce(this._map, event, handler);\n\n      if (this._listeners[event] === undefined) {\n        this._listeners[event] = [];\n      }\n\n      this._listeners[event].push(listener);\n    };\n\n\n    /**\n     * Alias for google.maps.event.addListener(object, event, handler)\n     */\n    this.addListener = function(object, event, handler) {\n      google.maps.event.addListener(object, event, handler);\n    };\n\n\n    /**\n     * Alias for google.maps.event.addListenerOnce(object, event, handler)\n     */\n    this.addListenerOnce = function(object, event, handler) {\n      google.maps.event.addListenerOnce(object, event, handler);\n    };\n\n\n    /**\n     * Alias for google.maps.event.trigger(map, event)\n     * @param {string} event an event defined on google.maps.Map\n     */\n    this.mapTrigger = function(event) {\n      google.maps.event.trigger(this._map, event);\n    };\n\n\n    /**\n     * Alias for google.maps.event.trigger(object, event)\n     */\n    this.trigger = function(object, event) {\n      google.maps.event.trigger(object, event);\n    };\n\n    this._newElement = function(type, opts) {\n        if (type === 'marker') {\n            if (!(opts.position instanceof google.maps.LatLng)) {\n              throw 'markerOptions did not contain a position';\n            }\n            return new angulargmDefaults.markerConstructor(opts);\n        } else if (type === 'polyline') {\n            if (!(opts.path instanceof Array)) {\n                throw 'polylineOptions did not contain a path';\n            }\n            return new angulargmDefaults.polylineConstructor(opts);\n        } else if (type === 'circle') {\n            if (!(opts.center instanceof google.maps.LatLng)) {\n                throw 'circleOptions did not contain a marker position';\n            }\n            return new angulargmDefaults.circleConstructor(opts);\n        }\n        else {\n          throw 'unrecognized type ' + type;\n        }\n    };\n\n    this._getElements = function(type) {\n        if (!(type in this._elements)) {\n            this._elements[type] = {};\n        }\n        return this._elements[type];\n    };\n\n    /**\n     * Adds a new element to the map.\n     * @return {boolean} true if an element was added, false if there was already\n     *   an element with the given id\n     * @throw if any arguments are null/undefined or elementOptions does not\n     *   have all the required options (i.e. position)\n     */\n    this.addElement = function(type, scopeId, id, elementOptions) {\n        assertDefined(type, 'type');\n        assertDefined(scopeId, 'scopeId');\n        assertDefined(id, 'id');\n        assertDefined(elementOptions, 'elementOptions');\n\n        if (this.hasElement(type, scopeId, id)) {\n          return false;\n        }\n\n        var elements = this._getElements(type);\n        if (elements[scopeId] == null) {\n          elements[scopeId] = {};\n        }\n\n        // google maps munges passed in options, so copy it first\n        // extend instead of copy to preserve value objects\n        var opts = {};\n        angular.extend(opts, elementOptions);\n        var element = this._newElement(type, opts);\n        elements[scopeId][id] = element;\n        element.setMap(this._map);\n\n        return true;\n    };\n\n    /**\n     * Updates an element on the map with new options.\n     * @return {boolean} true if an element was updated, false if there was no\n     *   element with the given id to update\n     * @throw if any arguments are null/undefined or elementOptions does not\n     *   have all the required options (i.e. position)\n     */\n\n    this.updateElement = function(type, scopeId, id, elementOptions) {\n      assertDefined(type, 'type');\n      assertDefined(scopeId, 'scopeId');\n      assertDefined(id, 'id');\n      assertDefined(elementOptions, 'elementOptions');\n\n      var element = this.getElement(type, scopeId, id);\n      if (element) {\n        element.setOptions(elementOptions);\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    this.hasElement = function(type, scopeId, id) {\n      assertDefined(type, 'type');\n      assertDefined(scopeId, 'scopeId');\n      assertDefined(id, 'id');\n      return (this.getElement(type, scopeId, id) != null);\n    };\n\n    /**\n     * @return {google maps element} the element with the given id, or null if no\n     *   such element exists\n     */\n    this.getElement = function (type, scopeId, id) {\n      assertDefined(type, 'type');\n      assertDefined(scopeId, 'scopeId');\n      assertDefined(id, 'id');\n\n      var elements = this._getElements(type);\n      if (elements[scopeId] != null && id in elements[scopeId]) {\n        return elements[scopeId][id];\n      } else {\n        return null;\n      }\n    };\n\n    /**\n     * @return {boolean} true if an element was removed, false if nothing\n     *   happened\n     */\n    this.removeElement = function(type, scopeId, id) {\n      assertDefined(type, 'type');\n      assertDefined(scopeId, 'scopeId');\n      assertDefined(id, 'id');\n\n      var elements = this._getElements(type);\n      var removed = false;\n      var element = elements[scopeId][id];\n      if (element) {\n          element.setMap(null);\n          removed = true;\n      }\n      elements[scopeId][id] = null;\n      delete elements[scopeId][id];\n      return removed;\n    };\n\n    /**\n     * Applies a function to each element on the map.\n     * @param {String} type of element, e.g. 'marker'\n     * @param {Function} fn will be called with element as first argument\n     * @throw if an argument is null or undefined\n     */\n    this.forEachElement = function(type, fn) {\n      assertDefined(type, 'type');\n      assertDefined(fn, 'fn');\n\n      var elements = this._getElements(type);\n      var scopeIds = Object.keys(elements);\n      var allElements = scopeIds.reduce(function(accumulator, scopeId) {\n        angular.forEach(elements[scopeId], function(element) {\n          accumulator.push(element);\n        });\n        return accumulator;\n      }, []);\n\n      angular.forEach(allElements, function(element, id) {\n        if (element != null) {\n          fn(element, id);\n        }\n      });\n    };\n\n\n    /**\n     * Applies a function to each element in a scope.\n     * @param {String} type of element, e.g. 'marker'\n     * @param {number} scope id\n     * @param {Function} fn will called with marker as first argument\n     * @throw if an argument is null or undefined\n     */\n    this.forEachElementInScope = function(type, scopeId, fn) {\n      assertDefined(type, 'type');\n      assertDefined(scopeId, 'scopeId');\n      assertDefined(fn, 'fn');\n\n      var elements = this._getElements(type);\n      angular.forEach(elements[scopeId], function(element, id) {\n        if (element != null) {\n          fn(element, id);\n        }\n      });\n    };\n\n    this.getMap = function() {\n      return this._map;\n    };\n\n    /** Instantiate controller */\n    angular.bind(this, constructor)($scope, $element);\n\n  }]);\n})();\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./scripts/libs/angular-gm.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n/** WEBPACK FOOTER **\n ** external \"async!/maps.google.com/maps/api/js?libraries=places\"\n **/","define(function (require, exports, module) {\n    'use strict';\n\n    exports.lpPlacesUtils = {\n        maxLengthLabel: 3, // Marker's label maximum size\n        markerColorPool: ['#FF8355', '#6FADD4', '#E69215', '#74AED3', '#C73935', '#443647', '#38706D', '#1D415B'],\n        markerWidth: 25,\n        markerHeight: 35,\n        markerFontFamily: 'Arial',\n        titleField: 'name', // Field used as title on the marker\n        alertTimeout: 5000, // Milliseconds until an alert will auto-close,\n        isCanvasSupported: function isCanvasSupported() {\n            return !!document.createElement('canvas').getContext;\n        },\n        maps: window.google && window.google.maps\n\n    };\n\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./scripts/utils.js\n **/","\ndefine(function (require, exports, module) {\n    'use strict';\n\n    // @ngInject\n    exports.lpPlaces = function(lpPlacesUtils) {\n\n        // Darw a canvas pin\n        var drawPin = function(context, width, height) {\n            var radius = width / 2;\n            context.beginPath();\n            context.moveTo(radius, height);\n            context.arc(radius, radius, radius, 0, Math.PI, true);\n            context.closePath();\n            context.fill();\n            context.stroke();\n        };\n\n        this.getFilterOptions = function(data) {\n\n            var types = data.types || [],\n                services = data.services || [];\n\n            return types.concat(services);\n        };\n\n        // Get url for a google pin with custom letter and color\n        this.googleIcon = function(label, color) {\n            if (color.charAt(0) === '#') {\n                color = color.substring(1);\n            }\n            return '//chart.apis.google.com/chart?chst=d_map_pin_letter&chld=' + label.charAt(0) + '|' + (color || 'FF0000');\n        };\n\n        // Create a data url for a canvas pin with custom label and color\n        this.canvasIcon = function(label, color, width, height) {\n            var canvas = document.createElement('canvas');\n            var context = canvas.getContext('2d');\n\n            width = width || lpPlacesUtils.markerWidth;\n            height = height || lpPlacesUtils.markerHeight;\n\n            canvas.width = width;\n            canvas.height = height;\n\n            context.clearRect(0, 0, width, height);\n\n            context.fillStyle = color;\n            context.strokeStyle = color;\n\n            drawPin(context, width, height);\n\n            context.fillStyle = 'white';\n            context.strokeStyle = 'black';\n\n            // Render Label\n            var fontSize = 10 - label.length; // Decide font size based on label's length\n            context.font = 'normal ' + fontSize + 'pt ' + lpPlacesUtils.markerFontFamily;\n            context.textBaseline = 'top';\n\n            // Centre text\n            var textWidth = context.measureText(label);\n            context.fillText(label, Math.floor((width / 2) - (textWidth.width / 2)), 4);\n\n            return canvas.toDataURL();\n        };\n\n    };\n\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./scripts/services.js\n **/","define(function (require, exports, module) {\n    'use strict';\n\n    var $ = require('jquery');\n\n    // @ngInject\n    exports.placesAutocomplete = function (lpPlacesUtils, lpCoreUtils) {\n\n        function linkFn(scope, element, attrs, ngModelCtrl) {\n            var autocomplete = new lpPlacesUtils.maps.places.Autocomplete(element[0]);\n\n            lpPlacesUtils.maps.event.addListener(autocomplete, 'place_changed', function () {\n                var place = autocomplete.getPlace(),\n                    isValid = !!place.geometry;\n\n                var args = {\n                    place: place\n                };\n\n                if (isValid) {\n                    args.location = place.geometry.location;\n                }\n\n                scope.$apply(function () {\n                    ngModelCtrl.$setValidity('place', isValid);\n                    ngModelCtrl.$setViewValue(element.val());\n                    scope.onPlaceChange({ result: args });\n                });\n            });\n\n            // Prevent IE from closing widget on enter\n            element.bind('keydown', function (e) {\n                if (e.keyCode === 13) {\n                    e.preventDefault();\n                }\n            });\n        }\n\n        return {\n            restrict: 'A',\n            require: 'ngModel',\n            scope: {\n                onPlaceChange: '&placesAutocomplete'\n            },\n            replace: false,\n            link: linkFn,\n            compile: function () {\n                /**\n                 * Fix to make the google maps autocomplete work in the webview using FastClick\n                 * http://stackoverflow.com/questions/21158507/google-places-autocomplete-issue-on-ios7-webview\n                 */\n                $(document).on({\n                    'DOMNodeInserted': function () {\n                        $('.pac-item, .pac-item span', this).addClass('needsclick');\n                    }\n                }, '.pac-container');\n\n                return linkFn;\n            }\n        };\n    };\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./scripts/places-autocomplete.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_11__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"jquery\"\n ** module id = 11\n ** module chunks = 0\n **/"],"sourceRoot":""}